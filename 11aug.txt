In [88]: Sub
Out[88]: <reflectivity.Substrate at 0x7f2293a2a890>

In [89]: layer1
Out[89]: <reflectivity.Epitaxial_Layer at 0x7f228fdcf790>

In [90]: layer1.subs
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-90-42ed98668368> in <module>()
----> 1 layer1.subs

AttributeError: 'Epitaxial_Layer' object has no attribute 'subs'

In [91]: layer1.strain
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-91-4630f9a17824> in <module>()
----> 1 layer1.strain

AttributeError: 'Epitaxial_Layer' object has no attribute 'strain'

In [92]: layer1.strain = dict(t=np.linspace(0,1000, 101), a = np.linspace(0, 0.01, 101)))
  File "<ipython-input-92-890838af6494>", line 1
    layer1.strain = dict(t=np.linspace(0,1000, 101), a = np.linspace(0, 0.01, 101)))
                                                                                   ^
SyntaxError: invalid syntax


In [93]: layer1.strain = dict(t=np.linspace(0,1000, 101), a = np.linspace(0, 0.01, 101))

In [94]: for layernum in xrange(len(layer1.strain["t"]))
  File "<ipython-input-94-1c444b767a35>", line 1
    for layernum in xrange(len(layer1.strain["t"]))
                                                   ^
SyntaxError: invalid syntax


In [95]: for layernum in xrange(len(layer1.strain["t"])):
    ...: print layernum
  File "<ipython-input-95-24a80f252612>", line 2
    print layernum
        ^
IndentationError: expected an indented block


In [96]: 

In [96]: for layernum in xrange(len(layer1.strain["t"])):
    ...:    print layernum
    ...: 
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

In [97]: (layer1.strain["a"] + 1) * layer1.structure.subs["a"]
Out[97]: 
array([ 3.9999    ,  4.00029999,  4.00069998,  4.00109997,  4.00149996,
        4.00189995,  4.00229994,  4.00269993,  4.00309992,  4.00349991,
        4.0038999 ,  4.00429989,  4.00469988,  4.00509987,  4.00549986,
        4.00589985,  4.00629984,  4.00669983,  4.00709982,  4.00749981,
        4.0078998 ,  4.00829979,  4.00869978,  4.00909977,  4.00949976,
        4.00989975,  4.01029974,  4.01069973,  4.01109972,  4.01149971,
        4.0118997 ,  4.01229969,  4.01269968,  4.01309967,  4.01349966,
        4.01389965,  4.01429964,  4.01469963,  4.01509962,  4.01549961,
        4.0158996 ,  4.01629959,  4.01669958,  4.01709957,  4.01749956,
        4.01789955,  4.01829954,  4.01869953,  4.01909952,  4.01949951,
        4.0198995 ,  4.02029949,  4.02069948,  4.02109947,  4.02149946,
        4.02189945,  4.02229944,  4.02269943,  4.02309942,  4.02349941,
        4.0238994 ,  4.02429939,  4.02469938,  4.02509937,  4.02549936,
        4.02589935,  4.02629934,  4.02669933,  4.02709932,  4.02749931,
        4.0278993 ,  4.02829929,  4.02869928,  4.02909927,  4.02949926,
        4.02989925,  4.03029924,  4.03069923,  4.03109922,  4.03149921,
        4.0318992 ,  4.03229919,  4.03269918,  4.03309917,  4.03349916,
        4.03389915,  4.03429914,  4.03469913,  4.03509912,  4.03549911,
        4.0358991 ,  4.03629909,  4.03669908,  4.03709907,  4.03749906,
        4.03789905,  4.03829904,  4.03869903,  4.03909902,  4.03949901,
        4.039899  ])

In [98]: (layer1.strain["a"][4] + 1) * layer1.structure.subs["a"]
Out[98]: 4.0014999599999994

In [99]: thissubs = layer1.structure.subs.copy()

In [100]: thissubs["a"]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-100-004819757977> in <module>()
----> 1 thissubs["a"]

KeyError: 'a'

In [101]: thissubs
Out[101]: {l: 0, a: 3.9999, c: 4.05717, h: 0, k: 0}

In [102]: 

In [102]: 

In [102]: for symbol in thissubs:
     ...:   print symbol
     ...: 
l
a
c
h
k

In [103]: for symbol in thissubs:
     ...:   print symbol.name
     ...: 
l
a
c
h
k

In [104]: for symbol in thissubs:
     ...:   print layer1.strain[symbol.name][42]
     ...: 
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-104-9529352d4129> in <module>()
      1 for symbol in thissubs:
----> 2   print layer1.strain[symbol.name][42]

KeyError: 'l'

In [105]: for symbol in thissubs:
     ...:   if symbol.name in layer1.strain:
     ...:       thissubs[symbol] = layer1.structure.subs[symbol] * (layer1.strain[symbol.name][42] + 1)
     ...: 

In [106]: thissubs
Out[106]: {l: 0, a: 4.01669958, c: 4.05717, h: 0, k: 0}

In [107]: thissubs = layer1.structure.subs.copy()

In [108]: 


























Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
wavelenght (A):  1.2398  Energy (eV):  10000
Bragg reflection: 
Matrix([[3], [0], [0]])
Surface:  Matrix([[1], [1], [0]])
Bragg plane angle to surface (degrees):  30.0
Bragg angle (degrees):  24.6521822504
Incident angle (degrees):  6.16865668915
Exit angle (degrees):  37.9517734808
Asymmetry factor:  -0.174724956587395

In [2]: layer1.structure.qfunc?
Type:       function
String Form:<function <lambda> at 0x7fdef2fa0cf8>
File:       Dynamically generated function. No source code available.
Definition: layer1.structure.qfunc(a, c, h, k, l)
Docstring:  sqrt(l**2/c**2 + h**2/a**2 + (h + 2*k)**2/(3*a**2))

In [3]: layer1.structure.q
Out[3]: 0

In [4]: layer1.structure??
Type:       unit_cell
String Form:<pyasf.pyasf.unit_cell object at 0x7fdef6050b10>
File:       /afs/desy.de/user/s/suracefm/.local/lib/python2.7/site-packages/pyasf/pyasf.py
Source:
class unit_cell(object):
    """
        This class represents the unit cell of a crystal in terms of Resonant
        Elastic X-Ray Scattering (REXS).
        After initialization one can:
            - fill it with atoms (self.add_atom) of the asymmetric unit
            - reduce degrees of freedom in their atomic scattering tensors
              by application of the crystals symmetry (self.get_tensor_symmetry)
            - generate all atoms on symmetry-equivalent sites (self.build_unit_cell)
            - calculate the Structure Factor in reciprocal coordinates up to 
              dipolar-quadrupolar contributions (self.F_..., self.calc_structure_factor)
            - transform it into the diffractometer system 
              (self.Fd_..., self.transform_structure_factor)
            - calculate the scattered field amplitus (self.E) at given azimut
              'psi' and glancing angle 'theta' (self.calc_scattered_amplitude)
            - try to simplify the resulting expressions in self.E (self.simplify)
        
        
        Units:
            energy : eV
            lambda = 12.398/energy
            
            unit_cell.q = 2 * sin(theta)/lambda
            
    """
    eps = 10*np.finfo(np.float64).eps
    u = 1.660538921e-27 # atomic mass unit
    electron_radius = 2.8179403e-15 # meters
    avogadro = 6.022142e23
    eV_A = 12398.42
    boltzmann = 1.380658e-23
    hbar = 1.054571628e-34 
    
    DEBUG = False
    def __init__(self, structure, resonant="", **kwargs):
        """
            Initializes the crystals unit cell for a given
            structure in the following steps:
                - retrieve space group generators for the given space group
                - calculate real and reciprocal lattice parameters
                - calculates Matrices B, B_0
                - calculates real and reciprocal metric tensors G, G_r

            Optionally loads a structure from a .cif file.
            See:
                Hall SR, Allen FH, Brown ID (1991).
                "The Crystallographic Information File (CIF):
                 a new standard archive file for crystallography".
                Acta Crystallographica A47 (6): 655-685
            A list or string of 'resonant' scattering atoms can be given.
            
            
            Input parameters:
                structure : either
                                - number of space group
                            or
                                - path to .cif-file
        """
        self.sg_sym = None
        self.AU_positions = {} # only asymmetric unit
        self.AU_formfactors = {} # only asymmetric unit, isotropic
        self.AU_formfactorsDD = {} # only asymmetric unit, pure dipolar
        self.AU_formfactorsDQ = {} # only asymmetric unit, dipolar-quadrupolar interference
        self.AU_formfactorsDDc = {} # only asymmetric unit, pure dipolar, cartesian
        self.AU_formfactorsDQc = {} # only asymmetric unit, dipolar-quadrupolar interference, cartesian
        self.miller = sp.symbols("h k l", integer=True)
        self.subs = SymbolDict()
        self.subs_U = SymbolDict()
        self.energy = sp.Symbol("epsilon", real=True)
        self.subs.update(dict(zip(self.miller, self.miller)))
        self.S = dict([(s.name, s) for s in self.miller]) # dictionary of all symbols
        self.S["q"] = sp.Symbol("q", real=True)
        self.elements = {}
        self.Uiso = collections.defaultdict(float)
        self.Uaniso = {}
        self.U = dict() # dictionary of anisotropic mean square displacement
        self.dE = dict() # dictionary of edge shifts
        self.f0func = dict()
        self.feff_func = dict()
        self.f = dict()
        self.f0 = dict()
        self.occupancy = dict()
        self.charges = collections.defaultdict(int)
        self.masses = dict()
        self.einstein_frequency = dict()
        
        if str(structure).isdigit():
            structure = int(structure)
            if structure<=230:
                print("Setting up space group %i..."%structure)
                self._init_lattice(int(structure))
            else:
                print("Looking up Crystallography Open Database for entry %i..."%structure)
                codurl = "http://www.crystallography.net/cod/%i.cif"%structure
                handle = urllib2.urlopen(codurl)
                text = handle.read()
                handle.close()
                ciffile = StringIO.StringIO(text)
                self.load_cif(ciffile, resonant, **kwargs)

        elif len(structure)==2 and str(structure[0]).isdigit():
            sg_num, self.sg_sym = structure
            self._init_lattice(int(sg_num))
        elif os.path.isfile(structure) and \
             os.path.splitext(structure)[1].lower()==".cif":
            self.load_cif(structure, resonant, **kwargs)
                    
        else:
            raise IOError("Invalid input for structure. Has to be either space group number or path to .cif-file")
            
    
    def _init_lattice(self, sg_num):
        self.sg_num = sg_num
        self.generators = map(np.array, get_generators(self.sg_num, self.sg_sym)) # fetch the space group generators
        if self.sg_sym!=None:
            self.transform = transform = get_ITA_settings(self.sg_num)[self.sg_sym]
        metrik = get_cell_parameters(self.sg_num, self.sg_sym)
        self.a, self.b, self.c, self.alpha, self.beta, self.gamma, self.system = metrik
        
        recparam = get_rec_cell_parameters(*metrik[0:6])
        self.ar, self.br, self.cr = recparam[:3] # reciprocal lattice parameters
        self.alphar, self.betar, self.gammar = recparam[3:6] # reciprocal lattice angles
        self.M, self.Minv = recparam[6:8] # transformation matrices
        dsub = {self.a:1, self.b:1, self.c:1}
        self.M0 = self.M.subs(dsub)#.subs(self.subs)
        self.M0inv = self.Minv.subs(dsub)#.subs(self.subs)
        self.metric_tensor, self.metric_tensor_inv = recparam[8:10] # metric tensors
        self.metric_tensor_0 = self.metric_tensor.subs(dsub)#.subs(self.subs)
        self.metric_tensor_inv_0 = self.metric_tensor_inv.subs(dsub)#.subs(self.subs)
        self.G = sp.Matrix(self.miller)
        # International Tables for Crystallography (2006). Vol. D, ch. 1.1, pp. 3-33
        # G is a vector in reciprocal space -> dual space, covariant
        # To transform it to cartesian space:
        # Gc = M * metric_tensor_inv * G
        #    = Minv.T * G 
        self.Gc = self.Minv.T * self.G
        self.Gc.simplify()
        self.q = self.Gc.norm()
        self.qfunc = makefunc(self.q, sp)
        self.V = sp.sqrt(self.metric_tensor.det())
        
    def add_atom(self, label, position, isotropic=True, assume_complex=True, dE=0, occupancy=1, charge=None):
        """
            Method to fill the asymmetric unit with atoms.
            
            Inputs:
            -------
                label : string
                    The label of the atom.
                    It has to be unique and to start with the symbold of the
                    chemical element.
                position : iterable of length 3
                    Position of the atom in the basis of the lattice vectors.
                isotropic : bool
                    Defines whether the atom is an isotropic scatterer which
                    is mostly the case far from absorption edges.
                assume_complex : bool
                    Defines whether the scalar atomic scattering amplitude shall
                    be assumed to be complex. This can be left False, since the
                    calculations are symbolic and values, that will be entered
                    later, still can be complex.
                dE : scalar
                    Sets the shift of the absorption edge for this particular
                    atom.
        """
        
        if not isinstance(label, str): raise TypeError("Invalid label. Need string.")
        if len(position) is not 3: raise TypeError("Enter 3D position object!")
        position = list(position)
        for i in range(3):
            if isinstance(position[i], str):
                position[i] = sp.S(Fraction(position[i]).limit_denominator(1000))
        #label = label.replace("_", "")
        labeltest = label[0].upper()
        if len(label) > 1:
            labeltest += label[1].lower()
        if labeltest in elements.Z.keys():
            element = labeltest
        elif labeltest[:1] in elements.Z.keys():
            element = labeltest[:1]
        else:
            raise ValueError("Atom label should start with the symbol of the chemical element" + \
                             "Chemical element not found in %s"%label)
        self.elements[label] = element
        self.AU_positions[label] = np.array(position)
        self.dE[label] = dE
        if charge!=None:
            self.charges[label] = int(charge)
        
        ion = self.get_ion(label)
        if not ion in self.f0func:
            # better agains sympy here? does it really make sense to have different q values for one reflection?
            self.f0func[ion] = makefunc(calc_f0(ion, self.S["q"]), "math")
        self.occupancy[label] = occupancy
        
        ind = xrange(3)
        U = sp.zeros(3,3)
        for i,j in itertools.product(ind, ind):
            if i<=j: 
                Sym = sp.Symbol("U_%s_%i%i"%(label, i+1, j+1), real=True)
                self.S[Sym.name] = Sym
                U[i,j] = U[j,i] = Sym
        self.U[label] = U
        
        ### FORM FACTORS:
        if assume_complex:
            my_ff_args = dict({"complex":True})
        else:
            my_ff_args = dict({"real":True})
        if isotropic:
            Sym = sp.Symbol("f_" + element, **my_ff_args)
            if Sym.name in self.S:
                Sym = self.S[Sym.name]
            else:
                self.S[Sym.name] = Sym
            self.AU_formfactors[label] = Sym
        else:
            self.resonant = element
            Sym = sp.Symbol("f_" + label + "_0", real=True)
            self.S[Sym.name] = Sym
            self.AU_formfactors[label] = Sym
            f_DD = np.zeros((3,3), dtype=object)
            for i,j in itertools.product(ind, ind):
                if i<=j: 
                    Sym = sp.Symbol("f_%s_dd_%i%i"%(label, i+1, j+1), **my_ff_args)
                    self.S[Sym.name] = Sym
                    f_DD[i,j] = Sym
                    if i<j:
                        f_DD[j,i] = Sym
            applymethod(f_DD, "simplify")
            
            ######### Transformation to lattice units:
            # M transforms vector from crystal units in direct space
            # to the cartesian system. Minv does the opposite.
            # M0 transforms the tensor from cartesian system to
            # crystal units allowing us to apply symmetry from ITC:
            self.AU_formfactorsDD[label] = full_transform(self.M0, f_DD)
            # transformation to lattice units:
            # self.AU_formfactorsDD[label] = full_transform(self.B_0.inv().T, f_DD)

            f_DQ = np.zeros((3,3,3), dtype=object)
            kindices = ("x", "y", "z")
            for h,i,j in itertools.product(ind, ind, ind):
                if j<=h:
                    Sym = sp.Symbol("f_%s_dq_%s%i%i"%(label, kindices[h], i+1, j+1), **my_ff_args)
                    self.S[Sym.name] = Sym
                    f_DQ[h,i,j] = Sym
                    if j<h:
                        f_DQ[j,i,h] = Sym
                        # See eq. 12 in Kokubun et al. http://dx.doi.org/10.1103/PhysRevB.82.205206
            applymethod(f_DQ, "simplify")
            # transformation to lattice units:
            self.AU_formfactorsDQ[label]  = full_transform(self.M0, f_DQ)
            #self.AU_formfactorsDQ[label] = full_transform(self.B_0, f_DQ)
            # transformation to lattice units:
            #self.AU_formfactorsDQ[label] = full_transform(self.B_0.inv().T, f_DQ)
            if self.DEBUG:
                print(self.AU_formfactorsDD[label], self.AU_formfactorsDQ[label])
    
    
    def get_ion(self, label):
        charge = self.charges[label]
        ion = self.elements[label]
        if charge > 0:
            ion += "%i+"%abs(charge)
        elif charge < 0:
            ion += "%i-"%abs(charge)
        else:
            pass
        return ion
    
    def load_cif(self, fname, resonant="", max_denominator=100):
        """
            Loads a structure from a .cif file.
            See:
                Hall SR, Allen FH, Brown ID (1991).
                "The Crystallographic Information File (CIF): a new standard archive file for crystallography".
                Acta Crystallographica A47 (6): 655-685
            
            A list or string of resonant scattering atoms can be given.
            
        """
        try:
            cf = CifFile.ReadCif(fname)
            self.cif = cif = cf.first_block()
        except Exception as e:
            print("File doesn't seem to be a valid .cif file: %s"%fname)
            raise IOError(e)
        if cif.has_key("_symmetry_int_tables_number"):
            sg_num = int(cif["_symmetry_int_tables_number"])
        elif cif.has_key("_space_group_IT_number"):
            sg_num = int(cif["_space_group_IT_number"])
        else:
            sg_num = None
            sg_sym = cif["_symmetry_space_group_name_h-m"]
            sg_sym = "".join(sg_sym.split())
            for i in range(1, 230):
                sett = get_ITA_settings(i)
                if sg_sym in sett:
                    sg_num = i
        if sg_num==None:
            raise ValueError("space group number could not be determined from .cif file `%s`:"%fname)
        ITA = get_ITA_settings(sg_num)
        if len(ITA)>1:
            print("Multiple settings found in space group %i"%sg_num)
            if cif.has_key("_symmetry_space_group_name_h-m"):
                sg_sym = cif["_symmetry_space_group_name_h-m"]
                sg_sym = "".join(sg_sym.split())
                if sg_sym.endswith("S"):
                    sg_sym = sg_sym[:-1] + ":1"
                if sg_sym.endswith("Z"):
                    sg_sym = sg_sym[:-1] + ":2"
                if sg_sym[-1] in ["R", "H"] and ":" not in sg_sym:
                    sg_sym = sg_sym[:-1] + ":" + sg_sym[-1]
                    
                settings = ITA.keys()
                sg_sym = sg_sym.lower()
                ratios = [difflib.SequenceMatcher(a=sg_sym, b=set.lower()).ratio() for set in settings]
                setting = settings[np.argmax(ratios)]
                print("  Identified symbol `%s' from .cif entry `%s'"\
                      %(setting, sg_sym))
                self.sg_sym = sg_sym = setting
            
        
        def getcoord(cifline):
            coord, digits = mkfloat(cifline, get_digits=True)
            if max_denominator==None:
                return coord
            coordrat = Fraction(coord)
            coordrat = coordrat.limit_denominator(max_denominator)
            if abs(coord-float(coordrat)) < (1*10**-digits):
                coord = coordrat
            return coord
        
        def getangle(cifline):
            ang, digits = mkfloat(cif[cifline], get_digits=True)
            ang = ang/180
            if max_denominator==None:
                return coord
            angrat = Fraction("%.15f"%ang)
            angrat = angrat.limit_denominator(max_denominator)
            if abs(ang-float(angrat)) < (1*10**-digits/180.):
                ang = angrat
            return sp.S(ang) * sp.pi
        
        self._init_lattice(sg_num)
        
        self.cifinfo = {}
        if cif.has_key("_chemical_formula_sum"):
            self.cifinfo["SumFormula"] = cif["_chemical_formula_sum"]
        self.subs[self.a] = mkfloat(self.cif["_cell_length_a"])
        self.subs[self.b] = mkfloat(self.cif["_cell_length_b"])
        self.subs[self.c] = mkfloat(self.cif["_cell_length_c"])
        if self.alpha.is_Symbol:
            self.subs[self.alpha] = getangle("_cell_angle_alpha")
        if self.beta.is_Symbol:
            self.subs[self.beta]  = getangle("_cell_angle_beta")
        if self.gamma.is_Symbol:
            self.subs[self.gamma] = getangle("_cell_angle_gamma")
        
        if not cif.has_key("_atom_site_label"):
            raise ValueError("No atoms found in .cif file")
        loop = cif.GetLoop("_atom_site_label")
        for key in loop.keys():
            loop[key.lower()] = loop[key]
        for line in loop:
            label = line._atom_site_label
            #symbol = line._atom_site_type_symbol
            try:
                charge = int(line._atom_site_type_symbol[-2:][::-1])
            except:
                charge = 0
            symbol = label[:2].capitalize()
            symbol = symbol if symbol in elements.Z else symbol[0]
            px = sp.S(getcoord(line._atom_site_fract_x))
            py = sp.S(getcoord(line._atom_site_fract_y))
            pz = sp.S(getcoord(line._atom_site_fract_z))
            occ = mkfloat(line._atom_site_occupancy) if loop.has_key("_atom_site_occupancy") else 1
            position = (px, py, pz)
            isotropic = (symbol not in resonant)
            if loop.has_key("_atom_site_u_iso_or_equiv"):
                iso = mkfloat(line._atom_site_u_iso_or_equiv)
            elif loop.has_key("_atom_site_b_iso_or_equiv"):
                iso = mkfloat(line._atom_site_b_iso_or_equiv)
                iso /= 8. * np.pi**2
            else:
                iso = 0
            
            self.Uiso[label] = iso
            self.add_atom(label, position, isotropic, assume_complex=True, 
                          occupancy=occ, charge=charge)
        
        if cif.has_key("_atom_site_aniso_label"):
            loop = cif.GetLoop("_atom_site_aniso_label")
            for key in loop.keys():
                loop[key.lower()] = loop[key]
            for num, line in enumerate(loop):
                label = line._atom_site_aniso_label
                self.Uaniso[label] = Uaniso = sp.zeros(3,3)
                for (i,j) in [(1,1), (1,2), (1,3), (2,2), (2,3), (3,3)]:
                    kw_U = "_atom_site_aniso_u_%i%i"%(i,j)
                    kw_B = "_atom_site_aniso_b_%i%i"%(i,j)
                    kw_beta = "_atom_site_aniso_beta_%i%i"%(i,j)
                    if loop.has_key(kw_U):
                        value = mkfloat(loop[kw_U][num])
                    elif loop.has_key(kw_B):
                        value = mkfloat(loop[kw_B][num])
                        value /= 8. * np.pi**2
                    elif loop.has_key(kw_beta):
                        value = mkfloat(loop[kw_beta][num])
                        value /= self.metric_tensor_inv[i-1,j-1] / 4.
                        value = value.subs(self.subs)
                        value /= 8. * np.pi**2
                    Uaniso[i-1,j-1] = Uaniso[j-1,i-1] = value
    
    
    
    def find_symmetry(self, start_sg=230):
        """
            Not yet perfect
        """
        element_pos = {}
        for label in self.AU_positions.keys():
            element = self.elements[label]
            if element in element_pos:
                element_pos[element].append(self.AU_positions[label])
            else:
                element_pos[element] = [self.AU_positions[label]]
        if self.DEBUG:
            print element_pos
        while start_sg>0:
            print("Trying space group %i..."%start_sg)
            UCtest = unit_cell(start_sg)
            skipSG = False
            for element in element_pos.keys():
                positions = np.array(copy.deepcopy(element_pos[element]))
                num = 1
                while len(positions)>0 and not skipSG:
                    UCtest.add_atom(element+str(num), positions[0])
                    UCtest.build_unit_cell()
                    for newpos in UCtest.positions[element+str(num)]:
                        ind = (((newpos - np.array(positions))**2).sum(1))<UCtest.mindist
                        if sum(ind)==1:
                            if self.DEBUG:
                                print "Found", newpos, "in", positions
                            positions = positions[~ind]
                        else:
                            print "Not found", newpos
                            skipSG = True
                            break
                    num+=1
                if skipSG: break
            if skipSG:
                start_sg-=1
            else:
                break
        return UCtest
    
    def get_tensor_symmetry(self, labels = None):
        """
            Applies Site Symmetries of the Space Group to the Scattering Tensors.
        """
        if labels == None:
            labels = self.U.iterkeys()
        self._equations = {}
        self._symmetries = {}
        self._Usymmetries = {}
        self._Uequations = {}
        M_r = sp.Matrix([self.ar, self.br, self.cr[0m])
        M_r = M_r * M_r.T
        for label in labels:
            equations = set()
            Uequations = set()
            U = self.U[label]
            Beta = U.multiply_elementwise(M_r)
            position = self.AU_positions[label]
            for generator in self.generators:
                W = sp.Matrix(generator[:,:3])
                w = generator[:,3].ravel()
                if self.DEBUG: print w, W
                new_position = W.dot(position) + w
                new_position = np.array([stay_in_UC(i) for i in new_position])
                if self.DEBUG: print new_position
                #if (new_position == self.AU_positions[label]).all(): #1.8.13
                dist = ((new_position - position)**2).sum()
                if dist < self.eps:
                    # International Tables for Crystallography (2006). Vol. D, ch. 1.1, pp. 3-33
                    # incident polarization is contravariant => f is 2 times covariant
                    # -> first axis in DD
                    # -> second axis in DQ
                    # W rotates position to new position
                    # -> that is the same as rotating polarization by W.inv
                    # -> To get representation of rotated tensor:
                    #     - rotate contracting Vectors (polarization) in opposite W.inv
                    #     ==> Transform Tensor with Rotation W
                    
                    if label in self.AU_formfactorsDD:
                        fDD = self.AU_formfactorsDD[label]
                        new_DD = full_transform(W, fDD)
                        equations.update((fDD - new_DD).ravel())
                    
                    if label in self.AU_formfactorsDQ:
                        fDQ = self.AU_formfactorsDQ[label]
                        new_DQ = full_transform(W, fDQ)
                        equations.update((fDQ - new_DQ).ravel())
                    
                    # U is 2 times contravariant so they transform the same
                    # way as the basis
                    # Therefore inverse 
                    #print W.T, W.inv()
                    #new_U =  full_transform(W.inv(), U)
                    #Uequations.update(np.ravel(new_U - U))
                    new_Beta = full_transform(W.inv(), Beta)
                    Uequations.update(np.ravel(new_Beta - Beta))
            equations.discard(0)
            Uequations.discard(0)
            if self.DEBUG:
                print label, equations
            self._equations[label] = equations
            self._Uequations[label] = Uequations
            
            
            if equations:
                ffSym = set()
                ffSym.update(np.ravel(self.AU_formfactorsDD.get(label, 0)))
                ffSym.update(np.ravel(self.AU_formfactorsDQ.get(label, 0)))
                ffSym.discard(0)
                symmetries =  sp.solve( equations, ffSym, dict=True, manual=True)
                self._symmetries[label] = symmetries = symmetries[0]
                if self.DEBUG:
                    print symmetries
                applymethod(self.AU_formfactorsDD[label], "subs", symmetries)
                applymethod(self.AU_formfactorsDD[label], "simplify")
                applymethod(self.AU_formfactorsDQ[label], "subs", symmetries)
                applymethod(self.AU_formfactorsDQ[label], "simplify")
                self.AU_formfactorsDDc[label]  = full_transform(self.M0inv, self.AU_formfactorsDD[label])
                self.AU_formfactorsDQc[label]  = full_transform(self.M0inv, self.AU_formfactorsDQ[label])
                applymethod(self.AU_formfactorsDDc[label], "simplify")
                applymethod(self.AU_formfactorsDQc[label], "simplify")
            
            Usymmetries = sp.solve(Uequations, sp.flatten(U), dict=True, manual=True)
            if Usymmetries:
                self._Usymmetries[label] = Usymmetries = Usymmetries[0]
                self.U[label] = U.subs(Usymmetries)
                self.U[label].simplify()
            
            if self.DEBUG:
                print self.AU_formfactorsDD[label], self.AU_formfactorsDQ[label]
    
    
    def _transform(self, generator, AU=False):
        """
            transform structure unit with a given generator.
        """
        generator = np.array(generator)
        if AU:
            positions = self.AU_positions
            formfactorsDD = self.AU_formfactorsDD
            formfactorsDQ = self.AU_formfactorsDQ
        else:
            positions = self.positions
            formfactorsDD = self.formfactorsDD
            formfactorsDQ = self.formfactorsDQ
        if generator.shape == (4, 3):
            generator = generator.T
        if generator.shape == (3, 4):
            W = generator[:,:3]
            w = generator[:,3].ravel()
        elif generator.shape == (3, 3):
            W = generator
            w = np.zeros(3)
        elif len(generator.ravel())==3:
            W = np.diag((1,1,1))
            w = generator.ravel()
        else:
            return
        for name in positions.keys():
            if AU:
                new_position = W.dot(positions[name]) + w
                new_position = new_position%1
                positions[name] = new_position
                if name in formfactorsDD:
                    formfactorsDD[name] = full_transform(W, formfactorsDD[name])
                if name in formfactorsDQ:
                    formfactorsDQ[name] = full_transform(W, formfactorsDQ[name])
            else:
                for i in range(len(positions[name])):
                    new_position = W.cot(positions[name][i]) + w
                    new_position = new_position%1
                    positions[name][i] = new_position
                    if name in formfactorsDD:
                        formfactorsDD[name][i] = full_transform(W, formfactorsDD[name][i])
                    if name in formfactorsDQ:
                        formfactorsDQ[name][i] = full_transform(W, formfactorsDQ[name][i])
    
    def build_unit_cell(self):
        """
            Generates all Atoms of the Unit Cell.
        """
        self.multiplicity = collections.defaultdict(int)
        self.positions = collections.defaultdict(list)
        self.formfactors = collections.defaultdict(list)
        self.formfactorsDD = collections.defaultdict(list)
        self.formfactorsDQ = collections.defaultdict(list)
        self.Beta = collections.defaultdict(list)
        M_r = sp.Matrix([self.ar, self.br, self.cr])
        M_r = M_r * M_r.T
        self._positions = []
        self._labels = []
        for label, position in self.AU_positions.iteritems():
            U = self.U[label]
            Beta = 2 * sp.pi**2 * U.multiply_elementwise(M_r)
            for generator in self.generators:
                W = sp.Matrix(generator[:,:3])
                w = generator[:,3].ravel()
                #print W, self.AU_positions[label], w
                new_position = W.dot(position) + w
                new_position = np.array([stay_in_UC(i) for i in new_position])
                if len(self.positions[label])>0: 
                    ind = ((new_position - np.array(self.positions[label]))**2).sum(1)
                else:
                    ind = np.array((1))
                if not (ind < self.eps).any():
                    #if new_position not in self.positions[label]:
                    self.Beta[label].append(sp.Matrix(full_transform(W.inv(), Beta)))
                    if label in self.AU_formfactors: 
                        self.formfactors[label].append(self.AU_formfactors[label])
                    if label in self.AU_formfactorsDD:
                        self.formfactorsDD[label].append(full_transform(W, self.AU_formfactorsDD[label]))
                    if label in self.AU_formfactorsDQ:
                        self.formfactorsDQ[label].append(full_transform(W, self.AU_formfactorsDQ[label]))
                    self.positions[label].append(new_position)
                    #sp.pprint(self.Beta[label][-1])
                    #sp.pprint(new_position)
                    self._positions.append(new_position)
                    self._labels.append(label)
                    self.multiplicity[label] += 1
        # rough estimate of the infimum of the distance of atoms:
        self._positions = np.vstack(self._positions)
        self._labels = np.array(self._labels)
        self.numato = sum(self.multiplicity.values())
        self.mindist = 1./self.numato**(1./3)/1000.
    
    
    def get_nearest_neighbors(self, label, num=1):
        num = int(num)
        if not num > 0:
            return
        
        pos = self.AU_positions[label].astype(float)
        diff = (pos - self._positions.astype(float))%1
        diff = np.vstack([diff, diff-np.array((0,0,1))])
        diff = np.vstack([diff, diff-np.array((0,1,0))])
        diff = np.vstack([diff, diff-np.array((1,0,0))])
        
        #diff =  (diff+0.5)%1-0.5
        M = np.array(self.M.subs(self.subs).n()).astype(float)
        self._diff = diff = diff.dot(M.T)
        #self._dist = dist = np.sqrt((diff**2).sum(1))
        self._dist = dist = np.linalg.norm(diff, axis=1)
        ind = dist.argsort()
        indlbl = ind%len(self._labels)
        return self._labels[indlbl[1:num+1]], dist[ind[1:num+1]]
    
    
    def get_density(self):
        """
            Calculates the density in g/cm^3 from the structure.
        """
        import rexs.xray.interactions as xi
        assert hasattr(self, "positions"), \
            "Unable to find atom positions. Did you forget to perform the unit_cell.build_unit_cell() method?"
        self.species = np.unique(self.elements.values())
        self.stoichiometry = collections.defaultdict(float)
        for label in self.elements:
            self.stoichiometry[self.elements[label]] += self.multiplicity[label] * self.occupancy[label]
        
        self.weights = dict([(atom, xi.get_element(atom)[1]) for atom in self.species])
        div = min(self.stoichiometry.values())
        components = ["%s%.2g"%(item[0], item[1]/div) for item in self.stoichiometry.iteritems()]
        components = map(lambda x: x[:-1] if (x[-1]=="1" and not x[-2].isdigit()) else x, components)
        self.SumFormula = "".join(components)
        
        
        self.total_weight = sum([self.weights[atom]*self.stoichiometry[atom] for atom in self.species])
        self.density = self.u * self.total_weight/1000. / (self.V*1e-10**3) # density in g/cm^3
        return float(self.density.subs(self.subs).n())

    def get_stoichiometry(self):
        """
            Returns the stoichiometry of the current sample
        """
        self.get_density()
        return self.SumFormula
    
    
    def calc_structure_factor(self, miller=None, DD=True, DQ=True, Temp=True, 
                                    subs=False, evaluate=False, Uaniso=True):
        """
            Takes the three Miller-indices of Type int and calculates the 
            Structure Factor in reciprocal basis.
        """
        if miller==None:
            miller = self.miller
        self.hkl(*miller)
        self.subs_U.clear()
        if not hasattr(self, "positions"):
            self.build_unit_cell()
        G = self.G.subs(self.subs)
        Gc = self.Gc.subs(self.subs)
        self.F_0 = sp.S(0)
        DD = DD and len(self.formfactorsDD)>0
        DD = DQ and len(self.formfactorsDQ)>0
        if DD:
            self.F_DD = np.zeros((3,3), object)
        if DQ:
            self.F_DQin = np.zeros((3,3,3), object)
            self.F_DQsc = np.zeros((3,3,3), object)
        if isinstance(Temp, bool):
            Temp = int(Temp)
        
        for label in self.positions: # get position, formfactor and symmetry if DQ tensor
            o = self.occupancy[label]
            if label in self.Uaniso and Uaniso:
                Uval = self.Uaniso[label]
            else:
                Uaniso = False
                Uval = self.Uiso[label]
            for i, r in enumerate(self.positions[label]):
                if Temp:
                    if Uaniso:
                        # International Tables for Crystallography (2006).
                        # Vol. D, Chapter 1.9, pp. 228.242.
                        Beta = self.Beta[label][i].subs(self.subs)
                        if subs:
                            Beta = Beta.subs(zip(self.U[label], Uval))
                        else:
                            self.subs_U.update(zip(self.U[label], Uval))
                        DW = sp.exp(-G.dot(Beta.dot(G))*Temp)
                        
                    else:
                        DW = sp.exp(-2 * sp.pi**2 * self.q**2 * Uval * Temp).subs(self.subs)
                else:
                    DW = 1
                
                if label in self.formfactors:
                    f = self.formfactors[label][i]
                    if self.DEBUG: print r, G.dot(r)
                    self.F_0 += o * f * sp.exp(2*sp.pi*sp.I * G.dot(r)) * DW
                if DD and label in self.formfactorsDD:
                    f = self.formfactorsDD[label][i]
                    self.F_DD += o * f * sp.exp(2*sp.pi*sp.I * G.dot(r)) * DW
                if DQ and label in self.formfactorsDQ:
                    f_in = self.formfactorsDQ[label][i]
                    f_sc = - f_in.copy().transpose(0,2,1)
                    #applymethod(f_sc, "conjugate") # only real parameters as in FDMNES!!!!?
                    #self.F_DQ += o * (f_in - f_out) * sp.exp(2*sp.pi*sp.I * G.dot(r)) * DW
                    self.F_DQin += o * f_in * sp.exp(2*sp.pi*sp.I * G.dot(r)) * DW
                    self.F_DQsc += o * f_sc * sp.exp(2*sp.pi*sp.I * G.dot(r)) * DW
        
        self.q = self.qfunc.dictcall(self.subs)
        self.d = 1/self.q
        self.theta = sp.asin(12398./(2*self.d*self.energy))

        #if subs:
        #    self.F_0 = self.F_0.subs(cs.subs)
        if evaluate:
            self.F_0 = self.F_0.n().expand()
        
        if self.F_0.has(sp.Symbol):
            self.F_0_func = makefunc(self.F_0)
        else:
            self.F_0_func = None
        # simplify:
        
        if DD:
            if subs:
                applymethod(self.F_DD, "subs", self.subs)
            if evaluate:
                applymethod(self.F_DD, "n")
            self.F_DD = ArraySimp2(self.F_DD)
        if DQ:
            if subs:
                applymethod(self.F_DQin, "subs", self.subs)
                applymethod(self.F_DQsc, "subs", self.subs)
            if evaluate:
                applymethod(self.F_DQin, "n")
                applymethod(self.F_DQsc, "n")
            self.F_DQin = ArraySimp2(self.F_DQin)
            self.F_DQsc = ArraySimp2(self.F_DQsc)
        
        return self.F_0
        
    def hkl(self, *miller, **kw):
        if miller:
            self.subs.update(zip(self.miller, miller))
        elif kw:
            miller = map(lambda S: S.name, self.miller)
            miller = dict(zip(miller, self.miller))
            subs = [(miller[k], v) for k,v in kw.iteritems() if k in miller]
            self.subs.update(subs)
        else:
            return tuple(self.subs[ind] for ind in self.miller)
    
    
    def transform_structure_factor(self, AAS = True, simplify=True, subs=True):
        """
            First transforms F to a real space, cartesian, crystal-fixed system ->Fc.
            Then transforms Fc to the diffractometer system, which is G along xd and sigma along zd ->Fd.
            
            This happens according to the work reported in:
            Acta Cryst. (1991). A47, 180-195 [doi:10.1107/S010876739001159X]
        """
        if not hasattr(self, "F_0") or \
           (AAS and (not hasattr(self, "F_DD") or not hasattr(self, "F_DQin"))):
            raise ValueError("No Reflection initialized. "
                             " Run self.calc_structure_factor() first.")
        # now the structure factors in a cartesian system follow
        self.Fc_0 = self.F_0.n().simplify()
        if AAS:
            #self.Fc_DD = full_transform(B_0_inv, self.F_DD) # RLU
            #self.Fc_DQ = full_transform(B_0_inv, self.F_DQ) # RLU
            self.Fc_DD   = full_transform(self.M0inv, self.F_DD)
            self.Fc_DQin = full_transform(self.M0inv, self.F_DQin)
            self.Fc_DQsc = full_transform(self.M0inv, self.F_DQsc)
        
        # and now: the rotation into the diffractometer system 
        #       (means rotation G into xd-direction)
        # calculate corresponding angles
        
        if subs:
            Gc = self.Gc.subs(self.subs)
        else:
            Gc = self.Gc.subs(zip(self.miller, self.hkl()))
        
        if Gc[1] == 0: phi = 0
        elif Gc[0] == 0: phi = sp.S("pi/2")*sp.sign(Gc[1])
        else: phi = sp.atan(Gc[1]/Gc[0])
        if Gc[2] == 0: xi = 0
        elif Gc[0] == 0 and Gc[1] == 0: xi = sp.S("pi/2")*sp.sign(Gc[2])
        else: xi = sp.atan(Gc[2]/sp.sqrt(Gc[0]**2 + Gc[1]**2))
        
        if simplify:
            if hasattr(xi,  "simplify"):
                xi  = xi.simplify()
            if hasattr(phi, "simplify"):
                phi = phi.simplify()
        self.xi, self.phi = xi, phi
        
        # introduce rotational matrices
        #  Drehung um z in -phi Richtung
        self.Phi = np.array([[ sp.cos(phi), sp.sin(phi), 0], 
                             [-sp.sin(phi), sp.cos(phi), 0], 
                             [0,                      0, 1]]) 
        #  Drehung um y in xi Richtung
        self.Xi  = np.array([[ sp.cos(xi), 0, sp.sin(xi)],
                             [          0, 1,          0], 
                             [-sp.sin(xi), 0, sp.cos(xi)]])
        
        # combined rotation
        self.Q = self.Xi.dot(self.Phi)
        #self.Q = self.Phi.dot(self.Xi)
        #self.Q = np.dot(self.Phi, self.Xi)
        if subs:
            applymethod(self.Q, "subs", self.subs)
            #applymethod(self.Q, "n")
        if simplify:
            applymethod(self.Q, "simplify")
            if AAS:
                self.Fc_DD = ArraySimp1(self.Fc_DD)
                self.Fc_DQin = ArraySimp1(self.Fc_DQin)
                self.Fc_DQsc = ArraySimp1(self.Fc_DQsc)
        
        self.Fd_0 = self.Fc_0
        if AAS:
            self.Fd_DD = full_transform(self.Q.T, self.Fc_DD)
            self.Fd_DQin = full_transform(self.Q.T, self.Fc_DQin)
            self.Fd_DQsc = full_transform(self.Q.T, self.Fc_DQsc)
        self.Q = sp.Matrix(self.Q)
        self.Gd = self.Q * Gc
        
    def transform_rec_lat_vec(self, miller, psi=0, inv=False):
        assert len(miller)==3, "Input has to be vector of length 3."
        miller = sp.Matrix(miller)
        if not hasattr(self, "Q"):
            self.transform_structure_factor()
        UB = self.Q * self.M * self.metric_tensor
        if psi!=0:
            Psi = np.array([[1, 0, 0], 
                           [0,sp.cos(psi),sp.sin(psi)], 
                           [0, -sp.sin(psi), sp.cos(psi)]])
            UB = sp.Matrix(Psi) * UB
        if inv:
            UB = UB.inv()
        return UB * miller
    
    
    def theta_degrees(self, energy=None, h=None, k=None, l=None):
        """
            Returns the Bragg angle (theta) in degree for a given energy in eV.
        """
        if energy!=None:
            self.subs[self.energy] = energy
        subs = zip(self.G, (h,k,l))
        subs = filter(lambda x: x[1]!=None, subs)
        subs = dict(subs)
        return sp.N(self.theta.subs(self.subs).subs(subs) * 180/sp.pi)
    
    
    def calc_scattered_amplitude(self, psi=None, assume_imag=False, assume_real=False,
                                       DD=True, [0mDQ=True, simplify=True, subs=True):
        
        self.transform_structure_factor(AAS = (DD+DQ), subs=subs, simplify=simplify)
        if psi==None:
            self.psi = psi = sp.Symbol("psi", real=True)
            self.S[psi.name] = psi
        
        sigma = sp.Matrix([0,0,1])
        k = self.energy / 12398.42
        self.k_plus = 2 * k * sp.cos(self.theta)
        pi_i = sp.Matrix([sp.cos(self.theta),  sp.sin(self.theta), 0])
        pi_s = sp.Matrix([sp.cos(self.theta), -sp.sin(self.theta), 0])
        
        vec_k_i = sp.Matrix([-sp.sin(self.theta), sp.cos(self.theta), 0]) #alt
        vec_k_s = sp.Matrix([ sp.sin(self.theta), sp.cos(self.theta), 0]) #alt
        self.vec_k_i, self.vec_k_s = vec_k_i, vec_k_s
        # introduce rotational matrix
        self.Psi = Psi = np.array([[1,            0,           0],
                                   [0,  sp.cos(psi), sp.sin(psi)],
                                   [0, -sp.sin(psi), sp.cos(psi)]])
        self.Fd_psi_0 = self.Fd_0.simplify()
        
        if DD:
            self.Fd_psi_DD = full_transform(Psi.T, self.Fd_DD)
            if simplify:
                applymethod(self.Fd_psi_DD, "simplify")
        if DQ:
            self.Fd_psi_DQin = full_transform(Psi.T, self.Fd_DQin)
            self.Fd_psi_DQsc = full_transform(Psi.T, self.Fd_DQsc)
            if simplify:
                applymethod(self.Fd_psi_DQin, "simplify")
                applymethod(self.Fd_psi_DQsc, "simplify")
        
        
#        # calculate symmetric and antisymmetric DQ Tensors
#        if DQ:
#            self.Fd_psi_DQ_out = self.Fd_psi_DQ.copy().transpose(0,2,1)
##            if assume_real:
##                pass
##            elif assume_imag:
##                self.Fd_psi_DQ_out *= -1
##            else:
##                applymethod(self.Fd_psi_DQ_out, "conjugate") # only real parameters as in FDMNES!!!!?
#            self.Fd_psi_DQs = (self.Fd_psi_DQ + self.Fd_psi_DQ_out)/2.
#            self.Fd_psi_DQa = -(self.Fd_psi_DQ - self.Fd_psi_DQ_out)/2.
        
#        
#        self.Fd = np.eye(3) * self.Fd_psi_0
#        if DD:
#            self.Fd += self.Fd_psi_DD
#        if DQ:
#            self.Fd += sp.I * self.q      * self.Fd_psi_DQs[0] \
#                     + sp.I * self.k_plus * self.Fd_psi_DQa[1]
#       
        # The Contraction: 
#        self.Fd_psi_DQ_out = self.Fd_psi_DQ.copy().transpose(0,2,1)
#        applymethod(self.Fd_psi_DQ_out, "conjugate") # only real parameters as in FDMNES!!!!?
        
        
        self.Fd = np.eye(3) * self.Fd_psi_0 \
                + self.Fd_psi_DD \
                + sp.I * ( np.tensordot(vec_k_i, self.Fd_psi_DQin, axes=(0,0)).squeeze() \
                         + np.tensordot(vec_k_s, self.Fd_psi_DQsc, axes=(0,0)).squeeze())
        
        self.Fd = sp.Matrix(self.Fd)
        if simplify:
            self.Fd.simplify()
        #self.Fd_alt = sp.Matrix(sp.expand(self.Fd_alt))
        
        
        self.E = {}
        self.E["ss"] = (sigma.T * self.Fd * sigma)[0] 
        self.E["sp"] = (pi_s.T * self.Fd * sigma)[0] # Vertauscht in und sc?
        self.E["ps"] = (sigma.T * self.Fd * pi_i)[0]
        self.E["pp"] = (pi_s.T * self.Fd * pi_i)[0]
        
        return True
    
    
    def feed_feff(self, label, energy, fprime, fsecond):
        """
            Input function for dispersion fine structure:
        """
        
        if label not in self.elements:
            raise ValueError("Atom name not found in structure: %s"%label)
        energy = np.array(energy)
        fprime = np.array(fprime)
        fsecond = np.array(fsecond)
        assert energy.ndim == fprime.ndim == fsecond.ndim == 1, \
            "Invalid dimensionality of input energy, fprime or fsecond"
        assert energy.shape == fprime.shape == fsecond.shape, \
            "Length of input arrays energy, fprime or fsecond disagree"
        
        element = self.elements[label]
        Z = elements.Z[element]
        if fprime.max()/Z > 0.1:
            fprime -= Z
            
        self.feff_func[label] = interp1d(energy, fprime + 1j*fsecond)
        
        return True
    
    
    
    def get_f1f2_isotropic(self, energy, fwhm_ev=1e-4, table="Sasaki"):
        isort = energy.argsort()
        emin, emax = energy[isort[[0, -1]]]
        atoms = list(self.AU_positions)
        if not hasattr(self, "_ftab") or \
           not set(self._ftab.atoms).issuperset(atoms) or \
           emin < self._ftab.x[0] or \
           emax > self._ftab.x[-1]:
            fwhm_ev = abs(fwhm_ev)
            if table=="deltafquad": # get resonant energies
                from rexs.xray import deltaf
                newenergy = []
                for label in atoms:
                    element = self.elements[label]
                    try:
                        newenergy.append(deltaf.get_energies(
                         element, emin, emax, fwhm_ev, verbose=False)[0])
                    except:
                        pass
                newenergy = np.sort(np.hstack(newenergy))
            else:
                newenergy = np.arange(emin-25, emax+25)
            ff_list = []
            for label in atoms:
                dE = self.dE[label]
                element = self.elements[label]
                Z = elements.Z[element]
                if self.DEBUG:
                    print("Fetching resonant dispersion corrections for %s "
                          "from table `%s`."%(element, table))
                if table=="deltafquad":
                    f1 = deltaf.getfquad(element, newenergy - dE,
                                                    fwhm_ev, f1f2="f1")
                    f2 = deltaf.getfquad(element, newenergy - dE,
                                                    fwhm_ev, f1f2="f2")
                    ff_list.append(f1 + 1j*f2)
                else:
                    import rexs.xray.interactions as xi
                    f1, f2 = xi.get_f1f2_from_db(element, newenergy - dE,
                                                               table=table)
                    if fwhm_ev>0:
                        f1 = ndimage.gaussian_filter1d(f1, fwhm_ev/2.355)
                        f2 = ndimage.gaussian_filter1d(f2, fwhm_ev/2.355)
                    ff_list.append(f1-Z + 1j*f2)
            self._ftab = interp1d(newenergy, ff_list, kind="linear")
            self._ftab.atoms = atoms
        
        f = self._ftab(energy)
        f =  dict(zip(self._ftab.atoms, f))
        
        for atom in self.feff_func:
            if atom in f:
                func = self.feff_func[atom]
                ind  = energy >= func.x.min()
                ind *= energy <= func.x.max()
                energy_sel = energy[ind]
                f1f2 = self.feff_func[atom](energy_sel)
                if hasattr(self, "fit_feff") and self.fit_feff:
                    imin  = energy_sel.argmin()
                    imax = energy_sel.argmax()
                    emin = max(self._ftab.x.min(), func.x.min())
                    emax = min(self._ftab.x.max(), func.x.max())
                    if emin > emax:
                        raise ValueError("invalid energy ranges")
                    feffl, feffr = func([emin, emax])
                    iatom = self._ftab.atoms.index(atom)
                    fsl, fsr = self._ftab([emin, emax])[iatom]
                    
                    # linear correction:
                    lin = (fsr/feffr - fsl/feffl)/(emax - emin) \
                                          * (energy_sel - emin) + fsl/feffl
                    f1f2 *= lin
                
                f[atom][ind] = f1f2
        
        self.f1f2 = f
        return f
    
    
    def get_tensors_FDMNES(self, path, label, Eedge, Emin=None, Emax=None):
        
        if label not in self.AU_formfactorsDD:
            raise ValueError("label %s not found in list of anisotric atoms"
                             %str(label))
        with open(path) as fh:
            header = fh.readline()
        header = header.split()
        if not header[0]=="Energy" and header[1]=="D_xxp":
            raise ValueError("%s doesn't seem to be a valid file of cartesian "
                             "tensors. (Need convoluted values)")
        
        data = np.loadtxt(path, skiprows=1)
        E = data[:,0] + Eedge
        ind = np.ones(len(E), dtype=bool)
        if Emin!=None:
            ind *= E > Emin
        if Emax!=None:
            ind *= E < Emax
        E = E[ind]
        data = data[ind]
        data = data.astype(complex)[:,1:]
        data[:,::2] += 1j * data[:,1::2]
        data = data[:,::2]
        header = map(lambda s: s.strip("p"), header[1::2])
        
        header = translate_fdmnes(header)
        
        data = named2darray(data.copy(), header)
        
        fiso = np.mean([data["dd_%s"%s] for s in ["11", "22", "33"]], 0) 
        
        data["dd_11"] -= fiso
        data["dd_22"] -= fiso
        data["dd_33"] -= fiso

        ftab = self.get_f1f2_isotropic(E)[label]
        lin = ((ftab[-1] - fiso[-1]) - (ftab[0] - fiso[0]))/(E[-1] - E[0]) \
                          * (E - E[0]) + (ftab[0] - fiso[0])
        fiso += lin
        self.feed_feff(label, E, fiso.real, fiso.imag)
        
        if not hasattr(self, "f_aniso"):
            self.f_aniso = dict()
        if not hasattr(self, "f_aniso_func"):
            self.f_aniso_func = dict()
        
        self.f_aniso[label] = data
        self.f_aniso_func[label] = interp1d(E, data.T, 
                                            bounds_error = False, 
                                            fill_value = 0.)
        self.f_aniso_func[label].components = header
        
        return E, data
    
    
    
    def get_absorption_isotropic(self, energy, density=None, table="Sasaki",
                                       fwhm_ev=0.25, f1f2=None):
        self.get_density()
        if density==None:
            density = float(self.density.subs(self.subs).n())
        
        if f1f2==None:
            f1f2 = self.get_f1f2_isotropic(energy, table=table, fwhm_ev=fwhm_ev)
        
        index_refraction = complex(0)
        
        for label in f1f2:
            element = self.elements[label]
            Z = elements.Z[element]
            
            index_refraction += (Z + f1f2[label]) * self.multiplicity[label]
            
        
        index_refraction *= self.electron_radius/(2*np.pi) \
                         * (self.eV_A*1e-10/energy)**2 \
                         * density * 1e6 * self.avogadro / self.total_weight
        
        self.index_of_refraction = index_refraction
        
        const = 10135467.657934014 # 2*eV/c/hbar
        mu = index_refraction.imag * const * energy
        return mu

    
    
    
    
    def DAFS(self, energy, miller, DD=False, DQ=False, Temp=True, psi=0,
             func_output=False, fwhm_ev=0.25, table="Sasaki", channel="ss",
             simplify=True, subs=True, force_refresh=True, Uaniso=True):
        """
            Calculates a Diffraction Anomalous Fine Structure (DAFS) curve for
            a given array of energies and a certain Bragg reflection hkl
            specified by the miller indices 3-tuple.
            The spectral fine structure of atoms is retrieved from a database
            specified in ``table``.
            Per default, dipole-dipole (DD) term as well as dipole-quadrupole
            (DQ) term are neglected.
            Alternatively, the atomic fine structure f1/f2 can be given for
            each site specified via {label:array} dictionary.
            They ``fwhm_ev`` keyword sets the resolution of the dispersion
            correction (f1, f2) when calculated via deltaf package by using
            ``table='deltaf'``. See the deltaf docstring for more information.
            If atoms of the same species shall be considered to be equivalent,
            the same fine structures are used.
            
            If ``func_output`` is True, a function for the structure amplitude
            F(E) is returned. Otherwise, it's the Intensity array.
        """
        if not hasattr(self, "F_0"):
            self.calc_structure_factor(miller, DD=DD, DQ=DQ, Temp=Temp,
                                       subs=subs, evaluate=subs, Uaniso=Uaniso)
        
        miller = tuple(map(int, miller))
        assert len(miller)==3, "Input for `miller` index must be 3-tuple of int"
        
        oldmiller = self.hkl()
        
        self.hkl(*miller)
        
        self.f.clear()
        f = self.f
        
        if not isinstance(energy, np.ndarray):
            energy = np.array(energy, dtype=float, ndmin=1)
        
        ### get dispersion correction:
        f1f2 = self.get_f1f2_isotropic(energy, fwhm_ev, table)
        
        
        
        ### get structure factor:
        if DD or DQ:
            if hasattr(self, "E") and miller==oldmiller:
                pass
            else:
                self.calc_structure_factor(miller, DD=DD, DQ=DQ, Temp=Temp,
                                       subs=subs, evaluate=subs, Uaniso=Uaniso)
                self.calc_scattered_amplitude(simplify=simplify, DD=DD, DQ=DQ,
                                              subs=subs, Uaniso=Uaniso)
            Feval = self.E[channel]
            f_aniso = dict()
            for sym in set.intersection(Feval.atoms(), self.S.values()):
                if not sym.name.startswith("f_"):
                    continue
                label = sym.name.split("_")[1]
                component = "_".join(sym.name.split("_")[2:])
                if component[:2] not in ["dd", "dq"]:
                    continue
                if not label in f_aniso and label in self.f_aniso_func:
                    func = self.f_aniso_func[label]
                    f_aniso[label] = named2darray(func(energy).T, func.components)
                #if component in f_aniso[label]:
                f[sym] = f_aniso[label][component]
            
            f[self.energy] = energy
            f[self.S["psi"]] = psi
        else:
            if hasattr(self, "F_0") and \
               (self.F_0.has(*self.miller) or miller==oldmiller) and not \
               force_refresh:
                if self.DEBUG:
                    print("Using cached SF")
            else:
                self.calc_structure_factor(miller, DD=DD, DQ=DQ, Temp=Temp,
                                   subs=subs, evaluate=subs, Uaniso=Uaniso)
                #subit = self.subs.iteritems()
                Feval = self.F_0.subs(self.subs.iteritems()).n().expand() # self.F_0.subs(self.subs).n().expand()
        
        
        
        q = self.qfunc.dictcall(self.subs).n()
        if self.f0.get("__q__") != q:
            self.f0.clear()
            self.f0["__q__"] = q
        
        for label in self.AU_formfactors:
            ffsymbol = self.AU_formfactors[label]
            ion = self.get_ion(label)
            if not ion in self.f0:
                if self.DEBUG:
                    print("Calculating nonresonant scattering amplitude for %s"%ion)
                self.f0[ion] = self.f0func[ion](q)
            
            f[ffsymbol] = f1f2[label] + self.f0[ion]
        
        
        
        if self.F_0_func != None:
            F0_func = self.F_0_func
            f.update(self.subs)
            f.update(self.subs_U)
        else:
            if simplify:
                Feval = Feval.simplify()
            self.Feval = Feval
            if len(energy)==1 and not func_output:
                return Feval.subs([(k,v.item()) for k,v in f.iteritems()])
            F0_func = makefunc(Feval)
        
        if func_output:
            return F0_func
        else:
            return F0_func.dictcall(f)
    
    
    
    def get_equivalent_vectors(self, v):
        return set([tuple(G[:,:3].T.dot(v)) for G in self.generators])
    
    
    def iter_rec_space(self, qmax, independent=True):
        """
        
            Returns an iterator over all Bragg reflections of the structures 
            as 3-tuples. The maximum value 2*sin(theta)/lambda is defined by
            qmax. If `independent` is True, only those reflections will be 
            included that are symetrically inequivalent.
        
        """
        qmax = abs(qmax)
        hmax = int(self.subs[self.a] * qmax)
        kmax = int(self.subs[self.b] * qmax)
        lmax = int(self.subs[self.c] * qmax)
        hind = xrange(hmax, -hmax-1, -1)
        kind = xrange(kmax, -kmax-1, -1)
        lind = xrange(lmax, -lmax-1, -1)
        iter1 = itertools.product(hind, kind, lind)
        self._Rdone = set()
        kwargs = self.subs.copy()
        kwargs.update(zip(self.miller, self.miller))
        qfunc = makefunc(self.qfunc.dictcall(kwargs).n(), np.math)
        def helper(R):
            if qfunc(*R) > qmax:
                return False
            if R in self._Rdone:
                return False
            if independent:
                self._Rdone.update(self.get_equivalent_vectors(R))
            return True
        return itertools.ifilter(helper, iter1)
        
    
    
    def set_msd_from_einstein(self, label, temperature, einstein_frequency=None, mass=None):
        """
            Sets the isotropic mean square displacement (unit_cell.U) of an 
            atom according to the Einstein model and a given temperature.
            If the mass is not given, it is taken from the database.
            
            Inputs:
                label : str
                    the label of the atom
                temperature : float
                    the temperature in kelvin
                einstein_frequency : float
                    the characteristic frequency in terms of the Einstein 
                    model
                mass : float (optional)
                    the mass of the atom in atomic mass units
                component : 2-tuple
                    the index of the tensor component described.
                    If `None` the isotropic displacement is used
            
            Returns:
                The isotropic mean square displacement in Angstrom^2
        """
        if not label in self.elements:
            raise ValueError("Atom labelled `%s` not found in unit_cell"%label)
        # http://dx.doi.org/10.1107/S0108767308031437
        element = self.elements[label]
        
        if mass != None:
            self.masses[element] = mass
        elif not element in self.masses:
            import rexs.xray.interactions as xi
            self.masses[element] = xi.get_element(element)[1]
        
        m = self.masses[element]
        
        omega = einstein_frequency
        if omega==None:
            omega = self.einstein_frequency[label]
        else:
            self.einstein_frequency[label] = omega
        
        if hasattr(omega, "shape") and omega.shape==(3,3):
            omega = np.array(omega).astype(float)
            msd =  self.hbar/(2 * m * self.u * omega ) \
                   / np.tanh(self.hbar * omega / (2*self.boltzmann*temperature)) \
                   *1e10**2
            self.Uaniso[label] = sp.Matrix(msd)
        else:
            msd =  self.hbar/(2 * m * self.u * omega ) \
                   / np.tanh(self.hbar * omega / (2*self.boltzmann*temperature)) \
                   *1e10**2
            self.Uiso[label] = msd
        return msd

    def set_temperature(self, temperature):
        """
            Sets the isotropic mean square displacement (unit_cell.U) of ech
            atom according to the Einstein model and a given temperature.
            
            Before using it, the characteristic frequency in the einstein 
            model needs to be given via the unit_cell.set_msd_from_einstein
            method.
            
            Inputs:
                temperature : float
                    the temperature in kelvin
        """
        omegas = [(label,self.einstein_frequency[label]) for label in self.elements]
        for label, omega in omegas:
            self.set_msd_from_einstein(label, temperature, omega)
    
    
    
    def simplify(self): # a longshot
        if not hasattr(self, "E"): return
        for pol in self.E:
            currlen = sp.count_ops(str(self.E[pol]))
            for i in range(3):
                print i
                for new in (sp.expand_mul(self.E[pol]), self.E[pol].expand(trig=True), sp.expand_complex(self.E[pol]).expand()):#, sp.trigsimp(self.E[pol])):
                    print currlen
                    if sp.count_ops(str(new))<currlen:
                        currlen=sp.count_ops(str(new))
                        self.E[pol] = new
        return self.E
    
    def eval_AAS(self, energy=None, table="Sasaki"):
        import rexs.xray.interactions as xi
        if energy!=None:
            self.subs[self.energy] = energy
        else:
            energy = float(self.subs[self.energy])
[0m        self.d = 1./self.qfunc.dictcall(self.subs)
        q = self.qfunc.dictcall(self.subs).n()
        for label in self.AU_formfactors:
            ffsymbol = self.AU_formfactors[label]
            element = self.elements[label]
            ion = self.get_ion(label)
            Z = elements.Z[element]
            f0 = self.f0func[ion](q)
            if ffsymbol.name.endswith("_0"):
                self.subs[ffsymbol] = f0
            else:
                dE = self.dE[label] # edge shift in eV
                try:
                    f_res = xi.get_f1f2_from_db(element, energy - dE, table=table)
                except:
                    f_res = xi.get_f1f2_from_db(element, energy - dE, table = "Henke")
                self.subs[ffsymbol] = sp.S(complex(f_res[0], f_res[1])) - Z + f0

        self.I = dict()
        self.AAS = dict()
        for pol in self.E:
            channel = self.E[pol].expand()
            channel = channel.subs(self.subs)
            #channel = channel.trigsimp()
            channel = channel.expand(Trig=True)
            channel = channel.n()
            self.AAS[pol] = channel
            Intensity = abs(channel)**2
            Intensity = Intensity.expand()
            self.I[pol] = makefunc(Intensity, "numpy")
        

    def get_F0(self, miller=None, energy=None, resonant=True, table="Sasaki", 
                     equivalent=False, Temp=False):
        import rexs.xray.interactions as xi
        if energy!=None:
            self.subs[self.energy] = energy
        else:
            energy = float(self.subs[self.energy])
        self.calc_structure_factor(miller, Temp=Temp)
        self.transform_structure_factor(AAS=False)
        
        done = []
        q = self.qfunc.dictcall(self.subs).n()
        for label in self.AU_formfactors:
            ffsymbol = self.AU_formfactors[label]
            element = self.elements[label]
            if equivalent:
                tmp = sp.Symbol("f_" + element)
                self.subs[ffsymbol] = tmp
                ffsymbol = tmp
                self.S[ffsymbol.name] = ffsymbol
            if ffsymbol in done:
                continue
            
            
            if self.DEBUG:
                print("Calculating nonresonant f_0 for %s..." %ffsymbol.name)
            Z = elements.Z[element]
            ion = self.get_ion(label)
            f0 = self.f0func[ion](q)

            if ffsymbol.name.endswith("_0"):
                self.subs[ffsymbol] = f0
            else:
                dE = self.dE[label] # edge shift in eV
                try:
                    f_res = xi.get_f1f2_from_db(element, energy - dE, table=table)
                except:
                    f_res = xi.get_f1f2_from_db(element, energy - dE, table = "Henke")
                if resonant:
                    self.subs[ffsymbol] = sp.S(complex(f_res[0], f_res[1])) - Z + f0
                else:
                    self.subs[ffsymbol] = f0
            done.append(ffsymbol)
        return self.F_0.subs(self.subs).subs(self.subs)
        

    def calc_reflection_angles(self, orientation, energy = None, **kwargs):
        """
            Calculates the angles of Bragg reflections relative to the surface
            of a crystal for given orientation (cut).
            Returns a (theta, psi)-tuple, where theta is the angle between the
            incident beam and the surface and psi is the azimuthal position.
        """
        if energy==None:
            if self.energy in self.subs:
                self.subs.pop(self.energy)
        else:
            self.subs[self.energy] = energy
        miller = list(sp.symbols("h,k,l", integer=True))
        for i in range(3):
            if miller[i].name in kwargs:
                miller[i] = kwargs[miller[i].name]
        
        psi2 = sp.Symbol("psi_2", real=True)
        self.S[psi2.name] = psi2
        
        self.calc_structure_factor(orientation, Temp=False)
        self.transform_structure_factor(AAS=False)
        Q = self.Q
        Gc = self.Gc.subs(self.subs).normalized()
        #sintheta = sp.sin(self.theta)
        #costheta = sp.sqrt(1 - sintheta**2)
        #vec_ki_d = sp.Matrix([-sintheta, costheta, 0])
        #self.vec_ki_d = vec_ki_d
        #ref_d = vec_ki_d.cross(self.Gd).T  # Reference vector for psi=0
        ref_d = sp.Matrix([0,0,1]) # Reference vector for psi=0
        ref_c = Q.T * ref_d
        ref_c.simplify()
        self.calc_structure_factor(miller, Temp=False) # secondary reflection
        self.transform_structure_factor(AAS=False)
        Q2 = self.Q
        Q2.simplify()
        sintheta2 = sp.sin(self.theta)
        costheta2 = sp.sqrt(1 - sintheta2**2)
        vec_ki2_d = sp.Matrix([-sintheta2, costheta2, 0])
        ref_d2 = Q2 * ref_c
        Gd = Q2 * Gc
        Psi2 = sp.Matrix([[1,             0,           0],
                          [0,  sp.cos(psi2), sp.sin(psi2)],
                          [0, -sp.sin(psi2), sp.cos(psi2)]])
        ref_d2_psi = Psi2 * ref_d2
        Gd_psi = Psi2 * Gd
        self.Gd_psi = Gd_psi
        newref = vec_ki2_d.cross(Gd_psi) # new mark
        #psi is the angle between ref_d2_psi and newref
        cospsi = newref.dot(ref_d2_psi)/(newref.norm()*ref_d2_psi.norm())
        sintheta = vec_ki2_d.dot(Gd_psi)/(vec_ki2_d.norm()*Gd_psi.norm())
        return sp.asin(sintheta), sp.acos(cospsi)
        
    
    def get_reflection_angles(self, orientation, energy=None):
        """
            For a given surface orientation, this method returns a function
            that, in turn, returns the (psi, theta) tuple of a given reflection
            and at a given energy.
        """
        if energy==None:
            if self.energy in self.subs:
                self.subs.pop(self.energy)
        else:
            self.subs[self.energy] = energy
        coordfunc = {}
        for miller in itertools.product([0,"h"], [0,"k"], [0,"l"]):
            key = "".join(map(str, miller))
            smth = zip(("h", "k", "l"), miller)
            kwargs = dict(filter(lambda x:x[1]==0, smth))
            kwvar = tuple(sorted(dict(filter(lambda x:x[1]!=0, smth)).keys()))
            theta, psi = self.calc_reflection_angles(orientation, **kwargs)
            print key
            coordfunc[key]  = lambdify(("psi_2", "epsilon") + kwvar, [psi.subs(self.subs), theta.subs(self.subs)], "numpy")
        def coordinates(miller, energy, psi2):
            key = zip(("h", "k", "l"), miller)
            kwargs = dict(filter(lambda x:x[1]!=0, key))
            key = map(lambda x: x[0] if x[1]!= 0 else "0", key)
            key = "".join(key)
            return coordfunc[key](psi2, energy, **kwargs)
        
        return coordinates

Constructor Docstring:
Initializes the crystals unit cell for a given
structure in the following steps:
    - retrieve space group generators for the given space group
    - calculate real and reciprocal lattice parameters
    - calculates Matrices B, B_0
    - calculates real and reciprocal metric tensors G, G_r

Optionally loads a structure from a .cif file.
See:
    Hall SR, Allen FH, Brown ID (1991).
    "The Crystallographic Information File (CIF):
     a new standard archive file for crystallography".
    Acta Crystallographica A47 (6): 655-685
A list or string of 'resonant' scattering atoms can be given.


Input parameters:
    structure : either
                    - number of space group
                or
                    - path to .cif-file

In [5]: 

In [5]: layer1.structure.Gc
Out[5]: 
Matrix([
[                    h/a],
[sqrt(3)*(h + 2*k)/(3*a)],
[                    l/c]])

In [6]: layer1.structure.Gc.norm()
Out[6]: sqrt(l**2/c**2 + h**2/a**2 + (h + 2*k)**2/(3*a**2))

In [7]: pyasf.makefunc
Out[7]: <function pyasf.pyasf.makefunc>

In [8]: pyasf.makefunc??
Type:       function
String Form:<function makefunc at 0x7fdef7f7f050>
File:       /afs/desy.de/user/s/suracefm/.local/lib/python2.7/site-packages/pyasf/pyasf.py
Definition: pyasf.makefunc(expr, mathmodule='numpy')
Source:
def makefunc(expr, mathmodule = "numpy"):
    symbols = list(expr.atoms(sp.Symbol))
    symbols.sort(key=str)
    func = lambdify(symbols, expr, mathmodule, dummify=False)
    func.kw = symbols
    func.kwstr = map(lambda x: x.name, symbols)
    func.dictcall = types.MethodType(dictcall, func)
    func.__doc__ = str(expr)
    return func


In [9]: pyasf.dictcall
Out[9]: <function pyasf.pyasf.<lambda>>

In [10]: pyasf.dictcall??
Type:       function
String Form:<function <lambda> at 0x7fdef7f7ac08>
File:       /afs/desy.de/user/s/suracefm/.local/lib/python2.7/site-packages/pyasf/pyasf.py
Definition: pyasf.dictcall(self, d)
Source:     dictcall = lambda self, d: self.__call__(*[d[k] for k in self.kw])


In [11]: layer1.structure.qfunc(l=1)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-11-a43461f9e905> in <module>()
----> 1 layer1.structure.qfunc(l=1)

TypeError: <lambda>() takes exactly 5 arguments (1 given)

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Traceback (most recent call last):
  File "/afs/desy.de/user/s/suracefm/Desktop/reflectivity/test11.py", line 3, in <module>
    import pyasf
  File "/afs/desy.de/user/s/suracefm/.local/lib/python2.7/site-packages/pyasf/__init__.py", line 1, in <module>
    from pyasf import *
  File "/afs/desy.de/user/s/suracefm/.local/lib/python2.7/site-packages/pyasf/pyasf.py", line 37
    dictcall = lambda self, d: self.__call__(*[d[k] for k in self.kw if k in d else k])
                                                                                  ^
SyntaxError: invalid syntax

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
wavelenght (A):  1.2398  Energy (eV):  10000
Bragg reflection: 
Matrix([[3], [0], [0]])
Surface:  Matrix([[1], [1], [0]])
Bragg plane angle to surface (degrees):  30.0
Bragg angle (degrees):  24.6521822504
Incident angle (degrees):  6.16865668915
Exit angle (degrees):  37.9517734808
Asymmetry factor:  -0.174724956587395

In [2]: layer1.structure.qfunc(l=1)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-2-a43461f9e905> in <module>()
----> 1 layer1.structure.qfunc(l=1)

TypeError: <lambda>() takes exactly 5 arguments (1 given)

In [3]: layer1.structure.qfunc.kw
Out[3]: [a, c, h, k, l]

In [4]: _[3]
Out[4]: k

In [5]: k = _

In [6]: layer1.structure.qfunc.dictcall({k:3})
Out[6]: sqrt(l**2/c**2 + h**2/a**2 + (h + 6)**2/(3*a**2))

In [7]: layer1.structure.qfunc?
Type:       function
String Form:<function <lambda> at 0x7fc01c9e3cf8>
File:       Dynamically generated function. No source code available.
Definition: layer1.structure.qfunc(a, c, h, k, l)
Docstring:  sqrt(l**2/c**2 + h**2/a**2 + (h + 2*k)**2/(3*a**2))

In [8]: layer1.structure.qfunc(a=1, c=2, h=3,k=4, l=5)
Out[8]: 7.45542308211501

In [9]: layer1.structure.qfunc(a=1, c=2, h=3,k=k, l=5)
Out[9]: sqrt((2*k + 3)**2/3 + 15.25)

In [10]: layer1.structure.qfunc(a=1, c=2, h=h,k=5, l=5)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-10-46f51f8fc059> in <module>()
----> 1 layer1.structure.qfunc(a=1, c=2, h=h,k=5, l=5)

NameError: name 'h' is not defined

In [11]: layer1.structure.qfunc(a=1, c=2, h="h",k=5, l=5)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-11-0e8c8da3b30d> in <module>()
----> 1 layer1.structure.qfunc(a=1, c=2, h="h",k=5, l=5)

/afs/desy.de/user/s/suracefm/.local/lib/python2.7/site-packages/sympy/__init__.pyc in <lambda>(a, c, h, k, l)

TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'

In [12]: layer1.structure.qfunc(a=1, c=2, h=3,k=k, l=5)
Out[12]: sqrt((2*k + 3)**2/3 + 15.25)

In [13]: layer1.structure.miller
Out[13]: (h, k, l)

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
Traceback (most recent call last):
  File "/afs/desy.de/user/s/suracefm/Desktop/reflectivity/test11.py", line 27, in <module>
    crystal.calc_g0_gH(Energy)
  File "reflectivity.py", line 16, in calc_g0_gH
    self.substrate.calc_g0_gH(Energy)
  File "reflectivity.py", line 226, in calc_g0_gH
    thetaBragg=self.calc_Bragg_angle(Energy).subs(self.structure.subs).evalf()
  File "reflectivity.py", line 197, in calc_Bragg_angle
    thissubs = dict(zip(layer1.structure.miller, Miller))
NameError: global name 'layer1' is not defined

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
Traceback (most recent call last):
  File "/afs/desy.de/user/s/suracefm/Desktop/reflectivity/test11.py", line 31, in <module>
    XRl = layer1.calc_reflection_amplitude(angle, Energy)
  File "reflectivity.py", line 171, in calc_reflection_amplitude
    self.calc_parameters(theta, Energy)
  File "reflectivity.py", line 157, in calc_parameters
    etaval = etafunc(theta)
TypeError: <lambda>() takes exactly 2 arguments (1 given)

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
17574997.3894005*pi*((0.174724956587395*theta - 0.174724956587395*asin(1.2398*sqrt(3)/a))*sin(2*asin(1.2398*sqrt(3)/a)) - 7.99527598994006e-8*(384.670219346627 + 9.96755359390751*I)/pi)/sqrt(41901.3429569699 + 4053.50677226613*I)
Traceback (most recent call last):
  File "/afs/desy.de/user/s/suracefm/Desktop/reflectivity/test11.py", line 31, in <module>
    XRl = layer1.calc_reflection_amplitude(angle, Energy)
  File "reflectivity.py", line 172, in calc_reflection_amplitude
    self.calc_parameters(theta, Energy)
  File "reflectivity.py", line 158, in calc_parameters
    etaval = etafunc(theta)
TypeError: <lambda>() takes exactly 2 arguments (1 given)

In [2]: layer1.etafunc?
Type:       function
String Form:<function <lambda> at 0x7f12afb646e0>
File:       Dynamically generated function. No source code available.
Definition: layer1.etafunc(a, theta)
Docstring:  17574997.3894005*pi*((0.174724956587395*theta - 0.174724956587395*asin(1.2398*sqrt(3)/a))*sin(2*asin(1.2398*sqrt(3)/a)) - 7.99527598994006e-8*(384.670219346627 + 9.96755359390751*I)/pi)/sqrt(41901.3429569699 + 4053.50677226613*I)

In [3]: pyasf.sp.lambdify
Out[3]: <function sympy.utilities.lambdify.lambdify>

In [4]: pyasf.sp.lambdify??
Type:       function
String Form:<function lambdify at 0x7f12d061ec08>
File:       /afs/desy.de/user/s/suracefm/.local/lib/python2.7/site-packages/sympy/utilities/lambdify.py
Definition: pyasf.sp.lambdify(args, expr, modules=None, printer=None, use_imps=True, dummify=True)
Source:
@doctest_depends_on(modules=('numpy'))
def lambdify(args, expr, modules=None, printer=None, use_imps=True,
        dummify=True):
    """
    Returns a lambda function for fast calculation of numerical values.

    If not specified differently by the user, SymPy functions are replaced as
    far as possible by either python-math, numpy (if available) or mpmath
    functions - exactly in this order. To change this behavior, the "modules"
    argument can be used. It accepts:

     - the strings "math", "mpmath", "numpy", "numexpr", "sympy"
     - any modules (e.g. math)
     - dictionaries that map names of sympy functions to arbitrary functions
     - lists that contain a mix of the arguments above, with higher priority
       given to entries appearing first.

    The default behavior is to substitute all arguments in the provided
    expression with dummy symbols. This allows for applied functions (e.g.
    f(t)) to be supplied as arguments. Call the function with dummify=False if
    dummy substitution is unwanted (and `args` is not a string). If you want
    to view the lambdified function or provide "sympy" as the module, you
    should probably set dummify=False.

    For functions involving large array calculations, numexpr can provide a
    significant speedup over numpy.  Please note that the available functions
    for numexpr are more limited than numpy but can be expanded with
    implemented_function and user defined subclasses of Function.  If specified,
    numexpr may be the only option in modules. The official list of numexpr
    functions can be found at:
    https://github.com/pydata/numexpr#supported-functions

    Deprecation Warnings
    ====================

    In previous releases ``lambdify`` replaced ``Matrix`` with ``numpy.matrix``
    by default. As of release 0.7.6 ``numpy.array`` is being transitioned to
    the default. In release 0.7.7 this transition will be complete. For now, to
    use the new default behavior you must pass in ``[{'ImmutableMatrix':
    numpy.array}, 'numpy']`` to the ``modules`` kwarg.

    >>> from sympy import lambdify, Matrix
    >>> from sympy.abc import x, y
    >>> import numpy
    >>> mat2array = [{'ImmutableMatrix': numpy.array}, 'numpy']
    >>> f = lambdify((x, y), Matrix([x, y]), modules=mat2array)
    >>> f(1, 2)
    array([[1],
           [2]])

    Usage
    =====

    (1) Use one of the provided modules:

        >>> from sympy import sin, tan, gamma
        >>> from sympy.utilities.lambdify import lambdastr
        >>> from sympy.abc import x, y
        >>> f = lambdify(x, sin(x), "math")

        Attention: Functions that are not in the math module will throw a name
                   error when the lambda function is evaluated! So this would
                   be better:

        >>> f = lambdify(x, sin(x)*gamma(x), ("math", "mpmath", "sympy"))

    (2) Use some other module:

        >>> import numpy
        >>> f = lambdify((x,y), tan(x*y), numpy)

        Attention: There are naming differences between numpy and sympy. So if
                   you simply take the numpy module, e.g. sympy.atan will not be
                   translated to numpy.arctan. Use the modified module instead
                   by passing the string "numpy":

        >>> f = lambdify((x,y), tan(x*y), "numpy")
        >>> f(1, 2)
        -2.18503986326
        >>> from numpy import array
        >>> f(array([1, 2, 3]), array([2, 3, 5]))
        [-2.18503986 -0.29100619 -0.8559934 ]

    (3) Use a dictionary defining custom functions:

        >>> def my_cool_function(x): return 'sin(%s) is cool' % x
        >>> myfuncs = {"sin" : my_cool_function}
        >>> f = lambdify(x, sin(x), myfuncs); f(1)
        'sin(1) is cool'

    Examples
    ========

    >>> from sympy.utilities.lambdify import implemented_function
    >>> from sympy import sqrt, sin, Matrix
    >>> from sympy import Function
    >>> from sympy.abc import w, x, y, z

    >>> f = lambdify(x, x**2)
    >>> f(2)
    4
    >>> f = lambdify((x, y, z), [z, y, x])
    >>> f(1,2,3)
    [3, 2, 1]
    >>> f = lambdify(x, sqrt(x))
    >>> f(4)
    2.0
    >>> f = lambdify((x, y), sin(x*y)**2)
    >>> f(0, 5)
    0.0
    >>> row = lambdify((x, y), Matrix((x, x + y)).T, modules='sympy')
    >>> row(1, 2)
    Matrix([[1, 3]])

    Tuple arguments are handled and the lambdified function should
    be called with the same type of arguments as were used to create
    the function.:

    >>> f = lambdify((x, (y, z)), x + y)
    >>> f(1, (2, 4))
    3

    A more robust way of handling this is to always work with flattened
    arguments:

    >>> from sympy.utilities.iterables import flatten
    >>> args = w, (x, (y, z))
    >>> vals = 1, (2, (3, 4))
    >>> f = lambdify(flatten(args), w + x + y + z)
    >>> f(*flatten(vals))
    10

    Functions present in `expr` can also carry their own numerical
    implementations, in a callable attached to the ``_imp_``
    attribute.  Usually you attach this using the
    ``implemented_function`` factory:

    >>> f = implemented_function(Function('f'), lambda x: x+1)
    >>> func = lambdify(x, f(x))
    >>> func(4)
    5

    ``lambdify`` always prefers ``_imp_`` implementations to implementations
    in other namespaces, unless the ``use_imps`` input parameter is False.
    """
    from sympy.core.symbol import Symbol
    from sympy.utilities.iterables import flatten

    # If the user hasn't specified any modules, use what is available.
    module_provided = True
    if modules is None:
        module_provided = False
        # Use either numpy (if available) or python.math where possible.
        # XXX: This leads to different behaviour on different systems and
        #      might be the reason for irreproducible errors.
        modules = ["math", "mpmath", "sympy"]

        #Attempt to import numpy
        try:
            _import("numpy")
        except ImportError:
            pass
        else:
            modules.insert(1, "numpy")

    # Get the needed namespaces.
    namespaces = []
    # First find any function implementations
    if use_imps:
        namespaces.append(_imp_namespace(expr))
    # Check for dict before iterating
    if isinstance(modules, (dict, str)) or not hasattr(modules, '__iter__'):
        namespaces.append(modules)
    else:
        # consistency check
        if 'numexpr' in modules and len(modules) > 1:
            raise TypeError("numexpr must be the only item in 'modules'")
        namespaces += list(modules)
    # fill namespace with first having highest priority
    namespace = {}
    for m in namespaces[::-1]:
        buf = _get_namespace(m)
        namespace.update(buf)
    _issue_7853_dep_check(namespaces, namespace, expr)

    if hasattr(expr, "atoms"):
        #Try if you can extract symbols from the expression.
        #Move on if expr.atoms in not implemented.
        syms = expr.atoms(Symbol)
        for term in syms:
            namespace.update({str(term): term})

    if 'numexpr' in namespaces and printer is None:
        #XXX: This has to be done here because of circular imports
        from sympy.printing.lambdarepr import NumExprPrinter as printer

    # Get the names of the args, for creating a docstring
    if not iterable(args):
        args = (args,)
    names = []
    # Grab the callers frame, for getting the names by inspection (if needed)
    callers_local_vars = inspect.currentframe().f_back.f_locals.items()
    for n, var in enumerate(args):
        if hasattr(var, 'name'):
            names.append(var.name)
        else:
            # It's an iterable. Try to get name by inspection of calling frame.
            name_list = [var_name for var_name, var_val in callers_local_vars
                    if var_val is var]
            if len(name_list) == 1:
                names.append(name_list[0])
            else:
                # Cannot infer name with certainty. arg_# will have to do.
                names.append('arg_' + str(n))

    # Create lambda function.
    lstr = lambdastr(args, expr, printer=printer, dummify=dummify)
    flat = '__flatten_args__'

    if flat in lstr:
        import itertools
        namespace.update({flat: flatten})
    func = eval(lstr, namespace)
    # Apply the docstring
    sig = "func({0})".format(", ".join(str(i) for i in names))
    sig = textwrap.fill(sig, subsequent_indent=' '*8)
    expr_str = str(expr)
    if len(expr_str) > 78:
        expr_str = textwrap.wrap(expr_str, 75)[0] + '...'
    func.__doc__ = ("Created with lambdify. Signature:\n\n{sig}\n\n"
                    "Expression:\n\n{expr}").format(sig=sig, expr=expr_str)
    return func


Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
17574997.3894005*pi*((0.174724956587395*theta - 0.174724956587395*asin(1.2398*sqrt(3)/a))*sin(2*asin(1.2398*sqrt(3)/a)) - 7.99527598994006e-8*(384.670219346627 + 9.96755359390751*I)/pi)/sqrt(41901.3429569699 + 4053.50677226613*I)
Traceback (most recent call last):
  File "/afs/desy.de/user/s/suracefm/Desktop/reflectivity/test11.py", line 31, in <module>
    XRl = layer1.calc_reflection_amplitude(angle, Energy)
  File "reflectivity.py", line 172, in calc_reflection_amplitude
    self.calc_parameters(theta, Energy)
  File "reflectivity.py", line 158, in calc_parameters
    etaval = etafunc(theta)
TypeError: <lambda>() takes exactly 2 arguments (1 given)

In [2]: layer1. etafunc
Out[2]: <function numpy.<lambda>>

In [3]: layer1.etafunc.expr
Out[3]: 17574997.3894005*pi*((0.174724956587395*theta - 0.174724956587395*asin(1.2398*sqrt(3)/a))*sin(2*asin(1.2398*sqrt(3)/a)) - 7.99527598994006e-8*(384.670219346627 + 9.96755359390751*I)/pi)/sqrt(41901.3429569699 + 4053.50677226613*I)

In [4]: layer1.etafunc.expr.simplify()
Out[4]: (-540.526877674177 - 14.0061027633386*I + 43578963.5267576*pi*sqrt(3.0*a**2 - 13.83393636)*(0.174724956587395*theta - 0.174724956587395*asin(1.2398*sqrt(3)/a))/a**2)/sqrt(41901.3429569699 + 4053.50677226613*I)

In [5]: 1j
Out[5]: 1j

In [6]: layer1. etafunc.kw
Out[6]: [a, theta]

In [7]: layer1. etafunc.kw[1]
Out[7]: theta

In [8]: _ + 1j
Out[8]: theta + 1.0*I

In [9]: layer1. etafunc.kw[1]
Out[9]: theta

In [10]: _ + sp.I
Out[10]: theta + I

In [11]: abs(_)
Out[11]: sqrt(theta**2 + 1)

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
Traceback (most recent call last):
  File "/afs/desy.de/user/s/suracefm/Desktop/reflectivity/test11.py", line 33, in <module>
    XT = layer1.calc_transmission_amplitude(angle, Energy)
  File "reflectivity.py", line 181, in calc_transmission_amplitude
    etaval=self.etaval
AttributeError: 'Epitaxial_Layer' object has no attribute 'etaval'

In [2]: layer1.calc_reflection_amplitude(angle, Energy)
Out[2]: 
array([ -5.27827737e-03 +5.98738693e-03j,
        -4.96088758e-03 +5.93685906e-03j,
        -4.64549366e-03 +5.86781337e-03j,
        -4.33309051e-03 +5.78029978e-03j,
        -4.02467285e-03 +5.67442098e-03j,
        -3.72123245e-03 +5.55033265e-03j,
        -3.42375529e-03 +5.40824333e-03j,
        -3.13321880e-03 +5.24841431e-03j,
        -2.85058902e-03 +5.07115925e-03j,
        -2.57681782e-03 +4.87684377e-03j,
        -2.31284015e-03 +4.66588475e-03j,
        -2.05957124e-03 +4.43874965e-03j,
        -1.81790395e-03 +4.19595550e-03j,
        -1.58870604e-03 +3.93806793e-03j,
        -1.37281758e-03 +3.66569991e-03j,
        -1.17104836e-03 +3.37951041e-03j,
        -9.84175435e-04 +3.08020294e-03j,
        -8.12940628e-04 +2.76852394e-03j,
        -6.58048226e-04 +2.44526101e-03j,
        -5.20162701e-04 +2.11124104e-03j,
        -3.99906530e-04 +1.76732821e-03j,
        -2.97858132e-04 +1.41442190e-03j,
        -2.14549891e-04 +1.05345441e-03j,
        -1.50466306e-04 +6.85388686e-04j,
        -1.06042248e-04 +3.11215798e-04j,
        -8.16613521e-05 -6.80475379e-05j,
        -7.76545253e-05 -4.51361616e-04j,
        -9.42985995e-05 -8.37666453e-04j,
        -1.31815117e-04 -1.22588458e-03j,
        -1.90369263e-04 -1.61492392e-03j,
        -2.70068938e-04 -2.00368068e-03j,
        -3.70963994e-04 -2.39104238e-03j,
        -4.93045610e-04 -2.77589085e-03j,
        -6.36245836e-04 -3.15710531e-03j,
        -8.00437287e-04 -3.53356549e-03j,
        -9.85433010e-04 -3.90415474e-03j,
        -1.19098650e-03 -4.26776316e-03j,
        -1.41679189e-03 -4.62329080e-03j,
        -1.66248431e-03 -4.96965075e-03j,
        -1.92764040e-03 -5.30577232e-03j,
        -2.21177897e-03 -5.63060412e-03j,
        -2.51436189e-03 -5.94311722e-03j,
        -2.83479509e-03 -6.24230813e-03j,
        -3.17242971e-03 -6.52720187e-03j,
        -3.52656343e-03 -6.79685488e-03j,
        -3.89644201e-03 -7.05035797e-03j,
        -4.28126088e-03 -7.28683911e-03j,
        -4.68016699e-03 -7.50546621e-03j,
        -5.09226069e-03 -7.70544975e-03j,
        -5.51659790e-03 -7.88604537e-03j,
        -5.95219227e-03 -8.04655637e-03j,
        -6.39801758e-03 -8.18633598e-03j,
        -6.85301022e-03 -8.30478973e-03j,
        -7.31607182e-03 -8.40137745e-03j,
        -7.78607197e-03 -8.47561535e-03j,
        -8.26185107e-03 -8.52707781e-03j,
        -8.74222328e-03 -8.55539915e-03j,
        -9.22597956e-03 -8.56027516e-03j,
        -9.71189083e-03 -8.54146450e-03j,
        -1.01987111e-02 -8.49879000e-03j,
        -1.06851810e-02 -8.43213972e-03j,
        -1.11700308e-02 -8.34146785e-03j,
        -1.16519839e-02 -8.22679552e-03j,
        -1.21297608e-02 -8.08821134e-03j,
        -1.26020818e-02 -7.92587180e-03j,
        -1.30676710e-02 -7.74000153e-03j,
        -1.35252600e-02 -7.53089328e-03j,
        -1.39735909e-02 -7.29890783e-03j,
        -1.44114206e-02 -7.04447365e-03j,
        -1.48375238e-02 -6.76808637e-03j,
        -1.52506967e-02 -6.47030810e-03j,
        -1.56497607e-02 -6.15176656e-03j,
        -1.60335656e-02 -5.81315399e-03j,
        -1.64009934e-02 -5.45522592e-03j,
        -1.67509615e-02 -5.07879974e-03j,
        -1.70824258e-02 -4.68475310e-03j,
        -1.73943844e-02 -4.27402212e-03j,
        -1.76858807e-02 -3.84759945e-03j,
        -1.79560059e-02 -3.40653212e-03j,
        -1.82039031e-02 -2.95191929e-03j,
        -1.84287689e-02 -2.48490980e-03j,
        -1.86298572e-02 -2.00669954e-03j,
        -1.88064814e-02 -1.51852873e-03j,
        -1.89580169e-02 -1.02167901e-03j,
        -1.90839035e-02 -5.17470438e-04j,
        -1.91836477e-02 -7.25828823e-06j,
        -1.92568247e-02 +5.07570196e-04j,
        -1.93030805e-02 +1.02559922e-03j,
        -1.93221333e-02 +1.54538793e-03j,
        -1.93137754e-02 +2.06547404e-03j,
        -1.92778744e-02 +2.58437752e-03j,
        -1.92143745e-02 +3.10060435e-03j,
        -1.91232975e-02 +3.61265045e-03j,
        -1.90047436e-02 +4.11900551e-03j,
        -1.88588922e-02 +4.61815703e-03j,
        -1.86860022e-02 +5.10859430e-03j,
        -1.84864122e-02 +5.58881249e-03j,
        -1.82605407e-02 +6.05731671e-03j,
        -1.80088858e-02 +6.51262613e-03j,
        -1.77320248e-02 +6.95327804e-03j,
        -1.74306139e-02 +7.37783200e-03j,
        -1.71053869e-02 +7.78487392e-03j,
        -1.67571549e-02 +8.17302007e-03j,
        -1.63868043e-02 +8.54092114e-03j,
        -1.59952960e-02 +8.88726624e-03j,
        -1.55836636e-02 +9.21078676e-03j,
        -1.51530114e-02 +9.51026026e-03j,
        -1.47045129e-02 +9.78451426e-03j,
        -1.42394078e-02 +1.00324299e-02j,
        -1.37590004e-02 +1.02529455e-02j,
        -1.32646564e-02 +1.04450601e-02j,
        -1.27578005e-02 +1.06078369e-02j,
        -1.22399133e-02 +1.07404063e-02j,
        -1.17125284e-02 +1.08419691e-02j,
        -1.11772286e-02 +1.09117997e-02j,
        -1.06356429e-02 +1.09492483e-02j,
        -1.00894430e-02 +1.09537444e-02j,
        -9.54033894e-03 +1.09247983e-02j,
        -8.99007597e-03 +1.08620044e-02j,
        -8.44043004e-03 +1.07650426e-02j,
        -7.89320382e-03 +1.06336805e-02j,
        -7.35022251e-03 +1.04677750e-02j,
        -6.81332945e-03 +1.02672741e-02j,
        -6.28438170e-03 +1.00322179e-02j,
        -5.76524555e-03 +9.76273986e-03j,
        -5.25779190e-03 +9.45906775e-03j,
        -4.76389166e-03 +9.12152413e-03j,
        -4.28541105e-03 +8.75052694e-03j,
        -3.82420686e-03 +8.34658960e-03j,
        -3.38212167e-03 +7.91032108e-03j,
        -2.96097915e-03 +7.44242554e-03j,
        -2.56257921e-03 +6.94370192e-03j,
        -2.18869328e-03 +6.41504313e-03j,
        -1.84105952e-03 +5.85743514e-03j,
        -1.52137815e-03 +5.27195575e-03j,
        -1.23130672e-03 +4.65977310e-03j,
        -9.72455539e-04 +4.02214407e-03j,
        -7.46383075e-04 +3.36041231e-03j,
        -5.54591505e-04 +2.67600612e-03j,
        -3.98522316e-04 +1.97043607e-03j,
        -2.79552016e-04 +1.24529241e-03j,
        -1.98987964e-04 +5.02242250e-04j,
        -1.58064310e-04 -2.56973446e-04j,
        -1.57938084e-04 -1.03054312e-03j,
        -1.99685416e-04 -1.81658805e-03j,
        -2.84297923e-04 -2.61316599e-03j,
        -4.12679254e-04 -3.41827498e-03j,
        -5.85641814e-04 -4.22985736e-03j,
        -8.03903670e-04 -5.04580398e-03j,
        -1.06808565e-03 -5.86395848e-03j,
        -1.37870867e-03 -6.68212185e-03j,
        -1.73619119e-03 -7.49805706e-03j,
        -2.14084703e-03 -8.30949381e-03j,
        -2.59288327e-03 -9.11413350e-03j,
        -3.09239844e-03 -9.90965419e-03j,
        -3.63938099e-03 -1.06937158e-02j,
        -4.23370794e-03 -1.14639652e-02j,
        -4.87514381e-03 -1.22180416e-02j,
        -5.56333981e-03 -1.29535822e-02j,
        -6.29783325e-03 -1.36682268e-02j,
        -7.07804727e-03 -1.43596243e-02j,
        -7.90329081e-03 -1.50254374e-02j,
        -8.77275881e-03 -1.56633486e-02j,
        -9.68553273e-03 -1.62710653e-02j,
        -1.06405813e-02 -1.68463257e-02j,
        -1.16367617e-02 -1.73869041e-02j,
        -1.26728205e-02 -1.78906164e-02j,
        -1.37473957e-02 -1.83553255e-02j,
        -1.48590183e-02 -1.87789466e-02j,
        -1.60061144e-02 -1.91594524e-02j,
        -1.71870077e-02 -1.94948786e-02j,
        -1.83999219e-02 -1.97833286e-02j,
        -1.96429838e-02 -2.00229786e-02j,
        -2.09142264e-02 -2.02120824e-02j,
        -2.22115921e-02 -2.03489764e-02j,
        -2.35329363e-02 -2.04320837e-02j,
        -2.48760315e-02 -2.04599186e-02j,
        -2.62385710e-02 -2.04310911e-02j,
        -2.76181732e-02 -2.03443105e-02j,
        -2.90123864e-02 -2.01983896e-02j,
        -3.04186929e-02 -1.99922481e-02j,
        -3.18345143e-02 -1.97249159e-02j,
        -3.32572163e-02 -1.93955366e-02j,
        -3.46841136e-02 -1.90033703e-02j,
        -3.61124759e-02 -1.85477962e-02j,
        -3.75395326e-02 -1.80283151e-02j,
        -3.89624789e-02 -1.74445517e-02j,
        -4.03784811e-02 -1.67962566e-02j,
        -4.17846828e-02 -1.60833074e-02j,
        -4.31782104e-02 -1.53057110e-02j,
        -4.45561794e-02 -1.44636040e-02j,
        -4.59157000e-02 -1.35572536e-02j,
        -4.72538835e-02 -1.25870587e-02j,
        -4.85678484e-02 -1.15535495e-02j,
        -4.98547264e-02 -1.04573876e-02j,
        -5.11116682e-02 -9.29936616e-03j,
        -5.23358504e-02 -8.08040865e-03j,
        -5.35244809e-02 -6.80156832e-03j,
        -5.46748052e-02 -5.46402689e-03j,
        -5.57841123e-02 -4.06909310e-03j,
        -5.68497408e-02 -2.61820092e-03j,
        -5.78690849e-02 -1.11290751e-03j,
        -5.88395995e-02 +4.45109115e-04j,
        -5.97588068e-02 +2.05405266e-03j,
        -6.06243008e-02 +3.71201146e-03j,
        -6.14337538e-02 +5.41696157e-03j,
        -6.21849207e-02 +7.16677017e-03j,
        -6.28756447e-02 +8.95919921e-03j,
        -6.35038621e-02 +1.07919093e-02j,
        -6.40676071e-02 +1.26624637e-02j,
        -6.45650160e-02 +1.45683330e-02j,
        -6.49943321e-02 +1.65068991e-02j,
        -6.53539096e-02 +1.84754605e-02j,
        -6.56422175e-02 +2.04712370e-02j,
        -6.58578434e-02 +2.24913748e-02j,
        -6.59994969e-02 +2.45329521e-02j,
        -6.60660128e-02 +2.65929841e-02j,
        -6.60563542e-02 +2.86684289e-02j,
        -6.59696150e-02 +3.07561934e-02j,
        -6.58050225e-02 +3.28531389e-02j,
        -6.55619396e-02 +3.49560872e-02j,
        -6.52398664e-02 +3.70618266e-02j,
        -6.48384422e-02 +3.91671183e-02j,
        -6.43574463e-02 +4.12687025e-02j,
        -6.37967998e-02 +4.33633047e-02j,
        -6.31565654e-02 +4.54476421e-02j,
        -6.24369487e-02 +4.75184300e-02j,
        -6.16382976e-02 +4.95723882e-02j,
        -6.07611029e-02 +5.16062471e-02j,
        -5.98059972e-02 +5.36167548e-02j,
        -5.87737545e-02 +5.56006829e-02j,
        -5.76652893e-02 +5.75548328e-02j,
        -5.64816548e-02 +5.94760424e-02j,
        -5.52240418e-02 +6.13611922e-02j,
        -5.38937767e-02 +6.32072111e-02j,
        -5.24923190e-02 +6.50110828e-02j,
        -5.10212592e-02 +6.67698518e-02j,
        -4.94823161e-02 +6.84806289e-02j,
        -4.78773337e-02 +7.01405973e-02j,
        -4.62082778e-02 +7.17470179e-02j,
        -4.44772328e-02 +7.32972347e-02j,
        -4.26863981e-02 +7.47886803e-02j,
        -4.08380836e-02 +7.62188808e-02j,
        -3.89347058e-02 +7.75854608e-02j,
        -3.69787838e-02 +7.88861480e-02j,
        -3.49729338e-02 +8.01187776e-02j,
        -3.29198650e-02 +8.12812970e-02j,
        -3.08223745e-02 +8.23717694e-02j,
        -2.86833417e-02 +8.33883779e-02j,
        -2.65057233e-02 +8.43294289e-02j,
        -2.42925478e-02 +8.51933558e-02j,
        -2.20469095e-02 +8.59787217e-02j,
        -1.97719632e-02 +8.66842224e-02j,
        -1.74709179e-02 +8.73086891e-02j,
        -1.51470309e-02 +8.78510903e-02j,
        -1.28036015e-02 +8.83105345e-02j,
        -1.04439653e-02 +8.86862713e-02j,
        -8.07148726e-03 +8.89776931e-02j,
        -5.68955581e-03 +8.91843364e-02j,
        -3.30157629e-03 +8.93058826e-02j,
        -9.10964533e-04 +8.93421585e-02j,
         1.47885953e-03 +8.92931369e-02j,
         3.86447838e-03 +8.91589363e-02j,
         6.24248328e-03 +8.89398208e-02j,
         8.60948079e-03 +8.86361996e-02j,
         1.09620991e-02 +8.82486259e-02j,
         1.32969943e-02 +8.77777960e-02j,
         1.56108570e-02 +8.72245480e-02j,
         1.79004179e-02 +8.65898597e-02j,
         2.01624548e-02 +8.58748470e-02j,
         2.23937978e-02 +8.50807614e-02j,
         2.45913357e-02 +8.42089875e-02j,
         2.67520218e-02 +8.32610404e-02j,
         2.88728793e-02 +8.22385625e-02j,
         3.09510071e-02 +8.11433202e-02j,
         3.29835849e-02 +7.99772006e-02j,
         3.49678789e-02 +7.87422071e-02j,
         3.69012462e-02 +7.74404561e-02j,
         3.87811400e-02 +7.60741726e-02j,
         4.06051142e-02 +7.46456851e-02j,
         4.23708278e-02 +7.31574220e-02j,
         4.40760491e-02 +7.16119060e-02j,
         4.57186599e-02 +7.00117493e-02j,
         4.72966586e-02 +6.83596482e-02j,
         4.88081648e-02 +6.66583784e-02j,
         5.02514213e-02 +6.49107884e-02j,
         5.16247983e-02 +6.31197950e-02j,
         5.29267953e-02 +6.12883766e-02j,
         5.41560440e-02 +5.94195678e-02j,
         5.53113102e-02 +5.75164532e-02j,
         5.63914962e-02 +5.55821613e-02j,
         5.73956420e-02 +5.36198584e-02j,
         5.83229268e-02 +5.16327426e-02j,
         5.91726701e-02 +4.96240367e-02j,
         5.99443327e-02 +4.75969829e-02j,
         6.06375167e-02 +4.55548357e-02j,
         6.12519662e-02 +4.35008558e-02j,
         6.17875669e-02 +4.14383039e-02j,
         6.22443458e-02 +3.93704339e-02j,
         6.26224707e-02 +3.73004870e-02j,
         6.29222489e-02 +3.52316854e-02j,
         6.31441262e-02 +3.31672257e-02j,
         6.32886854e-02 +3.11102730e-02j,
         6.33566442e-02 +2.90639552e-02j,
         6.33488535e-02 +2.70313562e-02j,
         6.32662947e-02 +2.50155107e-02j,
         6.31100774e-02 +2.30193985e-02j,
         6.28814362e-02 +2.10459381e-02j,
         6.25817276e-02 +1.90979823e-02j,
         6.22124269e-02 +1.71783122e-02j,
         6.17751244e-02 +1.52896322e-02j,
         6.12715212e-02 +1.34345652e-02j,
         6.07034258e-02 +1.16156477e-02j,
         6.00727495e-02 +9.83532520e-03j,
         5.93815016e-02 +8.09594811e-03j,
         5.86317851e-02 +6.39976736e-03j,
         5.78257920e-02 +4.74893056e-03j,
         5.69657976e-02 +3.14547842e-03j,
         5.60541561e-02 +1.59134124e-03j,
         5.50932948e-02 +8.83358117e-05j,
         5.40857086e-02 -1.36183752e-03j,
         5.30339546e-02 -2.75759749e-03j,
         5.19406465e-02 -4.09748429e-03j,
         5.08084487e-02 -5.38016164e-03j,
         4.96400700e-02 -6.60441866e-03j,
         4.84382587e-02 -7.76917133e-03j,
         4.72057954e-02 -8.87346383e-03j,
         4.59454880e-02 -9.91646941e-03j,
         4.46601649e-02 -1.08974912e-02j,
         4.33526695e-02 -1.18159623e-02j,
         4.20258536e-02 -1.26714465e-02j,
         4.06825718e-02 -1.34636373e-02j,
         3.93256753e-02 -1.41923580e-02j,
         3.79580060e-02 -1.48575608e-02j,
         3.65823904e-02 -1.54593257e-02j,
         3.52016338e-02 -1.59978593e-02j,
         3.38185149e-02 -1.64734930e-02j,
         3.24357796e-02 -1.68866816e-02j,
         3.10561359e-02 -1.72380005e-02j,
         2.96822481e-02 -1.75281439e-02j,
         2.83167317e-02 -1.77579222e-02j,
         2.69621484e-02 -1.79282585e-02j,
         2.56210006e-02 -1.80401864e-02j,
         2.42957272e-02 -1.80948459e-02j,
         2.29886985e-02 -1.80934803e-02j,
         2.17022121e-02 -1.80374324e-02j,
         2.04384881e-02 -1.79281403e-02j,
         1.91996656e-02 -1.77671338e-02j,
         1.79877987e-02 -1.75560295e-02j,
         1.68048528e-02 -1.72965268e-02j,
         1.56527012e-02 -1.69904029e-02j,
         1.45331220e-02 -1.66395084e-02j,
         1.34477952e-02 -1.62457621e-02j,
         1.23983001e-02 -1.58111463e-02j,
         1.13861130e-02 -1.53377013e-02j,
         1.04126045e-02 -1.48275207e-02j,
         9.47903851e-03 -1.42827457e-02j,
         8.58656974e-03 -1.37055598e-02j,
         7.73624295e-03 -1.30981838e-02j,
         6.92899160e-03 -1.24628698e-02j,
         6.16563707e-03 -1.18018961e-02j,
         5.44688814e-03 -1.11175618e-02j,
         4.77334067e-03 -1.04121811e-02j,
         4.14547756e-03 -9.68807772e-03j,
         3.56366904e-03 -8.94758003e-03j,
         3.02817312e-03 -8.19301512e-03j,
         2.53913638e-03 -7.42670371e-03j,
         2.09659497e-03 -6.65095485e-03j,
         1.70047586e-03 -5.86806069e-03j,
         1.35059836e-03 -5.08029142e-03j,
         1.04667587e-03 -4.28989027e-03j,
         7.88317822e-04 -3.49906858e-03j,
         5.75031920e-04 -2.71000107e-03j,
         4.06226536e-04 -1.92482118e-03j,
         2.81213346e-04 -1.14561661e-03j,
         1.99210170e-04 -3.74424963e-04j,
         1.59343991e-04 +3.86770435e-04j,
         1.60654177e-04 +1.13604453e-03j,
         2.02095866e-04 +1.87153437e-03j,
         2.82543521e-04 +2.59144274e-03j,
         4.00794645e-04 +3.29404161e-03j,
         5.55573640e-04 +3.97767540e-03j,
         7.45535796e-04 +4.64076398e-03j,
         9.69271413e-04 +5.28180554e-03j,
         1.22531003e-03 +5.89937915e-03j,
         1.51212476e-03 +6.49214720e-03j,
         1.82813672e-03 +7.05885755e-03j,
         2.17171953e-03 +7.59834544e-03j,
         2.54120386e-03 +8.10953521e-03j,
         2.93488212e-03 +8.59144179e-03j,
         3.35101306e-03 +9.04317190e-03j,
         3.78782653e-03 +9.46392510e-03j,
         4.24352818e-03 +9.85299450e-03j,
         4.71630417e-03 +1.02097673e-02j,
         5.20432596e-03 +1.05337252e-02j,
         5.70575498e-03 +1.08244443e-02j,
         6.21874735e-03 +1.10815949e-02j,
         6.74145851e-03 +1.13049414e-02j,
         7.27204784e-03 +1.14943412e-02j,
         7.80868323e-03 +1.16497446e-02j,
         8.34954553e-03 +1.17711927e-02j,
         8.89283297e-03 +1.18588171e-02j,
         9.43676546e-03 +1.19128378e-02j,
         9.97958882e-03 +1.19335618e-02j,
         1.05195789e-02 +1.19213811e-02j,
         1.10550454e-02 +1.18767708e-02j,
         1.15843361e-02 +1.18002865e-02j,
         1.21058403e-02 +1.16925621e-02j,
         1.26179923e-02 +1.15543073e-02j,
         1.31192751e-02 +1.13863044e-02j,
         1.36082237e-02 +1.11894061e-02j,
         1.40834280e-02 +1.09645317e-02j,
         1.45435357e-02 +1.07126643e-02j,
         1.49872553e-02 +1.04348474e-02j,
         1.54133587e-02 +1.01321815e-02j,
         1.58206834e-02 +9.80582030e-03j,
         1.62081348e-02 +9.45696753e-03j,
         1.65746881e-02 +9.08687280e-03j,
         1.69193904e-02 +8.69682795e-03j,
         1.72413622e-02 +8.28816316e-03j,
         1.75397985e-02 +7.86224302e-03j,
         1.78139705e-02 +7.42046252e-03j,
         1.80632263e-02 +6.96424305e-03j,
         1.82869920e-02 +6.49502838e-03j,
         1.84847717e-02 +6.01428051e-03j,
         1.86561487e-02 +5.52347572e-03j,
         1.88007849e-02 +5.02410042e-03j,
         1.89184213e-02 +4.51764713e-03j,
         1.90088778e-02 +4.00561047e-03j,
         1.90720522e-02 +3.48948315e-03j,
         1.91079202e-02 +2.97075203e-03j,
         1.91165345e-02 +2.45089426e-03j,
         1.90980235e-02 +1.93137341e-03j,
         1.90525902e-02 +1.41363573e-03j,
         1.89805109e-02 +8.99106503e-04j,
         1.88821340e-02 +3.89186427e-04j,
         1.87578774e-02 -1.14751844e-04j,
         1.86082276e-02 -6.11367088e-04j,
         1.84337370e-02 -1.09935277e-03j,
         1.82350219e-02 -1.57744020e-03j,
         1.80127603e-02 -2.04440151e-03j,
         1.77676892e-02 -2.49905257e-03j,
         1.75006020e-02 -2.94025570e-03j,
         1.72123459e-02 -3.36692227e-03j,
         1.69038192e-02 -3.77801511e-03j,
         1.65759679e-02 -4.17255082e-03j,
         1.62297829e-02 -4.54960185e-03j,
         1.58662970e-02 -4.90829847e-03j,
         1.54865813e-02 -5.24783054e-03j,
         1.50917422e-02 -5.56744911e-03j,
         1.46829180e-02 -5.86646785e-03j,
         1.42612755e-02 -6.14426427e-03j,
         1.38280064e-02 -6.40028083e-03j,
         1.33843237e-02 -6.63402580e-03j,
         1.29314588e-02 -6.84507394e-03j,
         1.24706571e-02 -7.03306707e-03j,
         1.20031751e-02 -7.19771435e-03j,
         1.15302767e-02 -7.33879247e-03j,
         1.10532295e-02 -7.45614558e-03j,
         1.05733015e-02 -7.54968513e-03j,
         1.00917576e-02 -7.61938945e-03j,
         9.60985588e-03 -7.66530318e-03j,
         9.12884468e-03 -7.68753656e-03j,
         8.64995890e-03 -7.68626447e-03j,
         8.17441691e-03 -7.66172545e-03j,
         7.70341727e-03 -7.61422036e-03j,
         7.23813567e-03 -7.54411105e-03j,
         6.77972188e-03 -7.45181883e-03j,
         6.32929683e-03 -7.33782270e-03j,
         5.88794977e-03 -7.20265761e-03j,
         5.45673557e-03 -7.04691243e-03j,
         5.03667211e-03 -6.87122788e-03j,
         4.62873781e-03 -6.67629430e-03j,
         4.23386926e-03 -6.46284931e-03j,
         3.85295903e-03 -6.23167539e-03j,
         3.48685359e-03 -5.98359729e-03j,
         3.13635132e-03 -5.71947945e-03j,
         2.80220080e-03 -5.44022322e-03j,
         2.48509912e-03 -5.14676408e-03j,
         2.18569040e-03 -4.84006879e-03j,
         1.90456447e-03 -4.52113240e-03j,
         1.64225571e-03 -4.19097534e-03j,
         1.39924201e-03 -3.85064032e-03j,
         1.17594393e-03 -3.50118929e-03j,
         9.72724059e-04 -3.14370036e-03j,
         7.89886432e-04 -2.77926466e-03j,
         6.27676214e-04 -2.40898322e-03j,
         4.86279498e-04 -2.03396387e-03j,
         3.65823272e-04 -1.65531809e-03j,
         2.66375557e-04 -1.27415792e-03j,
         1.87945698e-04 -8.91592885e-04j,
         1.30484815e-04 -5.08726918e-04j,
         9.38864132e-05 -1.26655384e-04j,
         7.79871408e-05 +2.53537904e-04j,
         8.25677016e-05 +6.30783581e-04j,
         1.07353911e-04 +1.00402959e-03j,
         1.52017896e-04 +1.37224393e-03j,
         2.16179430e-04 +1.73441739e-03j,
         2.99407408e-04 +2.08956614e-03j,
         4.01221440e-04 +2.43673426e-03j,   5.21093577e-04 +2.77499616e-03j])

In [3]: layer1.Q
Out[3]: 17574997.3894005*I*pi*((0.174724956587395*theta - 0.174724956587395*asin(1.2398*
sqrt(3)/a))*sin(2*asin(1.2398*sqrt(3)/a)) - 7.99527598994006e-8*(384.67021934662
7 + 9.96755359390751*I)/pi)*sin((0.0900405756190912 + 0.00434702411765165*I)*sqr
t(308880533237436.0*pi**2*((0.174724956587395*theta - 0.174724956587395*asin(1.2
398*sqrt(3)/a))*sin(2*asin(1.2398*sqrt(3)/a)) - 7.99527598994006e-8*(384.6702193
46627 + 9.96755359390751*I)/pi)**2/(44341.8845881081 + 4291.52227415478*I) - 1))
/sqrt(44341.8845881081 + 4291.52227415478*I) + sqrt(308880533237436.0*pi**2*((0.
174724956587395*theta - 0.174724956587395*asin(1.2398*sqrt(3)/a))*sin(2*asin(1.2
398*sqrt(3)/a)) - 7.99527598994006e-8*(384.670219346627 + 9.96755359390751*I)/pi
)**2/(44341.8845881081 + 4291.52227415478*I) - 1)*cos((0.0900405756190912 + 0.00
434702411765165*I)*sqrt(308880533237436.0*pi**2*((0.174724956587395*theta - 0.17
4724956587395*asin(1.2398*sqrt(3)/a))*sin(2*asin(1.2398*sqrt(3)/a)) - 7.99527598
994006e-8*(384.670219346627 + 9.96755359390751*I)/pi)**2/(44341.8845881081 + 429
1.52227415478*I) - 1))

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
Traceback (most recent call last):
  File "/afs/desy.de/user/s/suracefm/Desktop/reflectivity/test11.py", line 33, in <module>
    XT = layer1.calc_transmission_amplitude(angle, Energy)
  File "reflectivity.py", line 181, in calc_transmission_amplitude
    eta=self.etav
AttributeError: 'Epitaxial_Layer' object has no attribute 'etav'

Kernel process terminated for restart. (0)

Python 2.7.6 (default, Jun 22 2015, 17:58:13) on linux2 (64 bits).
This is the IEP interpreter. Failed to integrate event loop for PYSIDE: No module named PySide

Using IPython 1.2.1 -- An enhanced Interactive Python.
?         -> Introduction and overview of IPython's features.
%quickref -> Quick reference.
help      -> Python's own help system.
object?   -> Details about 'object', use 'object??' for extra details.

In [1]: (executing lines 1 to 42 of "test11.py")
Multiple settings found in space group 161
  Identified symbol `R3c:h' from .cif entry `r3c:h'
Trigonal (hexagonal setting)
wavelenght (A):  1.2398  Energy (eV):  10000
Bragg reflection: 
Matrix([[3], [0], [0]])
Surface:  Matrix([[1], [1], [0]])
Bragg plane angle to surface (degrees):  30.0
Bragg angle (degrees):  24.6521822504
Incident angle (degrees):  6.16865668915
Exit angle (degrees):  37.9517734808
Asymmetry factor:  -0.174724956587395

In [2]: 